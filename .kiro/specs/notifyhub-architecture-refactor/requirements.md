# 需求文档

## 概述

本文档概述了 NotifyHub 包全面架构重构的需求。当前实现存在显著的设计问题，包括违反单一职责原则 (SRP)、伪异步实现、冗余类型定义、复杂调用链以及不一致的配置模式。此次重构旨在创建一个清洁、可维护且高性能的通知系统，具有适当的关注点分离。

## 需求

### 需求1：消除代码冗余和单一职责原则违反

**用户故事：** 作为维护 NotifyHub 的开发者，我希望拥有清洁、单一用途的包和文件，以便代码库更容易理解、修改和扩展。

#### 验收标准

1. 当检查代码库时，系统不应存在超过300行且职责混杂的文件
2. 当分析包结构时，每个包应具有单一、明确定义的职责
3. 当审查类型定义时，Message、Target 和其他核心类型应只有一个标准定义
4. 如果结构在多个地方定义，系统应合并为单一权威定义
5. 当检查 `hub_factory.go` 时，它应被拆分为专注的、单一职责的模块

### 需求2：实现真正的异步处理和回调支持

**用户故事：** 作为使用 NotifyHub 的开发者，我希望拥有真正的异步消息处理和全面的回调支持，以便在不阻塞应用程序的情况下处理通知。

#### 验收标准

1. 当调用 `SendAsync()` 时，系统应使用真实队列异步处理消息
2. 当异步操作完成时，系统应触发相应的结果回调
3. 当异步操作失败时，系统应触发相应的错误回调
4. 当处理批量操作时，系统应提供进度回调
5. 如果异步操作被取消，系统应停止处理并清理资源
6. 当异步操作完成时，系统应提供统一的 AsyncHandle 接口用于状态检查

### 需求3：简化调用链并消除冗余适配器

**用户故事：** 作为调试 NotifyHub 的开发者，我希望拥有简化的调用链和最少的抽象层，以便我可以轻松跟踪执行流程并提高性能。

#### 验收标准

1. 当用户调用客户端方法时，调用链不应超过3层（Client → Core → Platform）
2. 当处理消息时，不应存在 `clientAdapter` 或其他冗余适配器
3. 当在类型之间转换时，应需要最少或无类型转换
4. 如果测量性能，简化链应提供25-30%的性能改进
5. 当跟踪执行时，开发者应能够跟踪流程而无需导航适配器层

### 需求4：统一配置方法

**用户故事：** 作为配置 NotifyHub 的开发者，我希望拥有单一、一致的配置方法，以便我可以轻松设置平台而不会产生混淆。

#### 验收标准

1. 当配置平台时，应只使用函数式选项模式
2. 当设置任何平台时，配置应遵循相同的 `WithPlatform(name, config)` 模式
3. 当提供平台特定选项时，它们应使用强类型配置结构
4. 如果需要向后兼容性，应通过清楚标记的废弃函数提供
5. 当加载配置时，系统应支持环境变量、YAML 和程序化选项

### 需求5：建立统一平台接口

**用户故事：** 作为添加新平台的开发者，我希望拥有单一、全面的平台接口，以便集成简单且一致。

#### 验收标准

1. 当实现平台时，应只有一个 Platform 接口需要实现
2. 当平台注册时，它应提供完整的能力描述
3. 当平台处理消息时，它们应使用相同的消息和目标类型
4. 如果平台有特定要求，它们应通过能力系统表达
5. 当平台处理错误时，它们应使用统一的错误类型和代码

### 需求6：实现全面的错误处理和健康监控

**用户故事：** 作为在生产环境中操作 NotifyHub 的开发者，我希望拥有全面的错误处理和健康监控，以便我可以诊断问题并确保系统可靠性。

#### 验收标准

1. 当任何错误发生时，它应使用适当的错误代码进行分类
2. 当平台失败时，系统应提供详细的错误上下文和元数据
3. 当检查系统健康时，每个组件应独立报告其状态
4. 如果适合重试，系统应实现带抖动的指数退避
5. 当错误发生时，它们应使用足够的上下文进行日志记录以便调试

### 需求7：创建模块化包架构

**用户故事：** 作为扩展 NotifyHub 的开发者，我希望拥有具有清晰边界的模块化包架构，以便我可以在不影响其他组件的情况下处理特定功能。

#### 验收标准

1. 当检查包时，每个包应具有清晰的输入/输出接口
2. 当包依赖其他包时，依赖关系应是单向的
3. 当添加新功能时，它应整洁地适应现有的包结构
4. 如果检测到循环依赖，构建应失败并显示清晰的错误消息
5. 当测试组件时，每个包应能够独立测试

### 需求8：提供模板管理系统

**用户故事：** 作为创建丰富通知的开发者，我希望拥有支持多种引擎的统一模板管理系统，以便我可以跨平台创建一致、格式良好的消息。

#### 验收标准

1. 当使用模板时，系统应支持 Go 模板、Mustache 和 Handlebars 引擎
2. 当使用模板时，它们应通过3层缓存（内存、Redis、数据库）高效缓存
3. 当提供模板变量时，它们应被验证并安全插值
4. 如果模板渲染失败，系统应提供带上下文的清晰错误消息
5. 当热重载模板时，活动模板应在不重启系统的情况下更新

### 需求9：在迁移过程中保持向后兼容性

**用户故事：** 作为具有现有 NotifyHub 集成的开发者，我希望拥有平滑的迁移路径和清晰的指导，以便我可以在不破坏现有功能的情况下升级。

#### 验收标准

1. 当升级时，应为每个破坏性更改提供清晰的迁移文档
2. 当使用旧API时，系统应提供带迁移指导的废弃警告
3. 当迁移完成时，所有核心功能应像以前一样工作
4. 如果破坏性更改是必要的，它们应使用前后示例进行文档化
5. 当提供迁移指南时，它们应在可能的情况下包含自动迁移脚本

### 需求10：达到性能和可维护性目标

**用户故事：** 作为产品负责人，我希望重构后的系统满足特定的性能和可维护性目标，以便重构投资提供可衡量的收益。

#### 验收标准

1. 当测量性能时，新系统应比当前实现实现30%的性能改进
2. 当计算代码指标时，系统应通过消除冗余减少40%的代码行数
3. 当添加新功能时，由于更清晰的架构，开发时间应减少50%
4. 如果测量内存使用，分配开销应通过统一类型减少40%
5. 当重构完成时，系统应通过所有现有功能测试
