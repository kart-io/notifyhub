# 需求文档

## 概述

本文档概述了 NotifyHub 包全面架构重构的需求。当前实现存在显著的设计问题，经过六维度深度分析发现关键架构缺陷：

### 关键问题识别

- **巨型文件问题**: `feishu/sender.go` 669行违反SRP原则，`hub_factory.go` 622行职责混杂
- **6层调用链复杂性**: `用户代码 → notifyhub.New → core.NewHub → HubImpl → Dispatcher → PlatformManager → Platform`
- **全局状态依赖**: `globalPlatformRegistry` 影响多实例并发使用和测试隔离
- **伪异步实现**: `SendAsync` 方法缺乏真正的队列异步处理机制
- **配置方式二元化**: 强类型配置与遗留map配置并存造成混乱
- **重复类型定义**: Message、Target等核心类型在多个包中重复定义

### 重构目标

此次重构旨在创建一个清洁、可维护且高性能的通知系统，实现：

- 调用链路从6层简化到3层，性能提升30%
- 代码库规模减少40%，消除重复和冗余
- 内存分配减少40%，统一类型定义
- 开发效率提升50%，清晰的架构设计
- 支持多实例并发使用，移除全局状态依赖

## 需求

### 需求1：消除代码冗余和单一职责原则违反

**用户故事：** 作为维护 NotifyHub 的开发者，我希望拥有清洁、单一用途的包和文件，以便代码库更容易理解、修改和扩展。

#### 验收标准

1. 当检查代码库时，系统不应存在超过300行且职责混杂的文件
2. 当分析包结构时，每个包应具有单一、明确定义的职责
3. 当审查类型定义时，Message、Target 和其他核心类型应只有一个标准定义
4. 如果结构在多个地方定义，系统应合并为单一权威定义
5. 当检查 `hub_factory.go` 时，它应被拆分为专注的、单一职责的模块

### 需求2：实现真正的异步处理和回调支持

**用户故事：** 作为使用 NotifyHub 的开发者，我希望拥有真正的异步消息处理和全面的回调支持，以便在不阻塞应用程序的情况下处理通知。

#### 验收标准

1. 当调用 `SendAsync()` 时，系统应使用真实队列异步处理消息
2. 当异步操作完成时，系统应触发相应的结果回调
3. 当异步操作失败时，系统应触发相应的错误回调
4. 当处理批量操作时，系统应提供进度回调
5. 如果异步操作被取消，系统应停止处理并清理资源
6. 当异步操作完成时，系统应提供统一的 AsyncHandle 接口用于状态检查

### 需求3：简化调用链并消除冗余适配器

**用户故事：** 作为调试 NotifyHub 的开发者，我希望拥有简化的调用链和最少的抽象层，以便我可以轻松跟踪执行流程并提高性能。

#### 验收标准

1. 当用户调用客户端方法时，调用链不应超过3层（Client → Core → Platform）
2. 当处理消息时，不应存在 `clientAdapter` 或其他冗余适配器
3. 当在类型之间转换时，应需要最少或无类型转换
4. 如果测量性能，简化链应提供25-30%的性能改进
5. 当跟踪执行时，开发者应能够跟踪流程而无需导航适配器层

### 需求4：统一配置方法

**用户故事：** 作为配置 NotifyHub 的开发者，我希望拥有单一、一致的配置方法，以便我可以轻松设置平台而不会产生混淆。

#### 验收标准

1. 当配置平台时，应只使用函数式选项模式
2. 当设置任何平台时，配置应遵循相同的 `WithPlatform(name, config)` 模式
3. 当提供平台特定选项时，它们应使用强类型配置结构
4. 如果需要向后兼容性，应通过清楚标记的废弃函数提供
5. 当加载配置时，系统应支持环境变量、YAML 和程序化选项

### 需求5：建立统一平台接口

**用户故事：** 作为添加新平台的开发者，我希望拥有单一、全面的平台接口，以便集成简单且一致。

#### 验收标准

1. 当实现平台时，应只有一个 Platform 接口需要实现
2. 当平台注册时，它应提供完整的能力描述
3. 当平台处理消息时，它们应使用相同的消息和目标类型
4. 如果平台有特定要求，它们应通过能力系统表达
5. 当平台处理错误时，它们应使用统一的错误类型和代码

### 需求6：实现全面的错误处理和健康监控

**用户故事：** 作为在生产环境中操作 NotifyHub 的开发者，我希望拥有全面的错误处理和健康监控，以便我可以诊断问题并确保系统可靠性。

#### 验收标准

1. 当任何错误发生时，它应使用适当的错误代码进行分类
2. 当平台失败时，系统应提供详细的错误上下文和元数据
3. 当检查系统健康时，每个组件应独立报告其状态
4. 如果适合重试，系统应实现带抖动的指数退避
5. 当错误发生时，它们应使用足够的上下文进行日志记录以便调试

### 需求7：创建模块化包架构

**用户故事：** 作为扩展 NotifyHub 的开发者，我希望拥有具有清晰边界的模块化包架构，以便我可以在不影响其他组件的情况下处理特定功能。

#### 验收标准

1. 当检查包时，每个包应具有清晰的输入/输出接口
2. 当包依赖其他包时，依赖关系应是单向的
3. 当添加新功能时，它应整洁地适应现有的包结构
4. 如果检测到循环依赖，构建应失败并显示清晰的错误消息
5. 当测试组件时，每个包应能够独立测试

### 需求8：提供模板管理系统

**用户故事：** 作为创建丰富通知的开发者，我希望拥有支持多种引擎的统一模板管理系统，以便我可以跨平台创建一致、格式良好的消息。

#### 验收标准

1. 当使用模板时，系统应支持 Go 模板、Mustache 和 Handlebars 引擎
2. 当使用模板时，它们应通过3层缓存（内存、Redis、数据库）高效缓存
3. 当提供模板变量时，它们应被验证并安全插值
4. 如果模板渲染失败，系统应提供带上下文的清晰错误消息
5. 当热重载模板时，活动模板应在不重启系统的情况下更新

### 需求9：在迁移过程中保持向后兼容性

**用户故事：** 作为具有现有 NotifyHub 集成的开发者，我希望拥有平滑的迁移路径和清晰的指导，以便我可以在不破坏现有功能的情况下升级。

#### 验收标准

1. 当升级时，应为每个破坏性更改提供清晰的迁移文档
2. 当使用旧API时，系统应提供带迁移指导的废弃警告
3. 当迁移完成时，所有核心功能应像以前一样工作
4. 如果破坏性更改是必要的，它们应使用前后示例进行文档化
5. 当提供迁移指南时，它们应在可能的情况下包含自动迁移脚本

### 需求11：消除全局状态依赖和支持多实例使用

**用户故事：** 作为构建高并发应用的开发者，我希望NotifyHub支持多实例并发使用而不依赖全局状态，以便我可以在同一应用中创建多个独立的通知客户端实例。

#### 验收标准

1. 当创建多个NotifyHub实例时，它们应完全独立且不共享状态
2. 当运行并发测试时，不同实例不应相互影响或产生竞争条件
3. 当移除globalPlatformRegistry时，平台注册应通过依赖注入实现
4. 如果需要平台发现，应通过实例级注册表实现
5. 当多个goroutine同时使用不同实例时，应保证线程安全

### 需求12：解决巨型文件和职责混杂问题

**用户故事：** 作为维护代码质量的开发者，我希望消除超大文件和职责混杂的设计问题，以便代码更易理解、测试和维护。

#### 验收标准

1. 当检查文件大小时，任何单个文件不应超过300行
2. 当分析文件职责时，每个文件应只负责单一明确的功能
3. 当重构feishu/sender.go时，应按功能拆分为多个文件
4. 如果文件包含多种职责，应拆分为专门的模块
5. 当重构hub_factory.go时，应分离工厂、配置、适配器逻辑

### 需求13：实现统一的模块组织架构

**用户故事：** 作为理解和扩展系统的开发者，我希望拥有清晰的模块组织架构，以便快速定位功能和添加新特性。

#### 验收标准

1. 当查看包结构时，应遵循建议的新包组织方式
2. 当添加新功能时，应能清楚知道应该放在哪个包中
3. 当导入包时，导入路径应简洁且具有自描述性
4. 如果模块间需要通信，应通过明确定义的接口
5. 当检查依赖关系时，应呈现清晰的单向依赖图

### 需求14：建立目标架构的性能基准

**用户故事：** 作为评估重构效果的开发者，我希望建立明确的性能基准和测量机制，以便验证重构是否达到预期目标。

#### 验收标准

1. 当测量调用链性能时，3层架构应比6层架构快30%
2. 当测量内存使用时，统一类型定义应减少40%内存分配
3. 当评估开发效率时，新架构下添加平台应减少50%时间
4. 如果进行基准测试，应包含吞吐量、延迟、内存使用指标
5. 当完成重构时，应提供详细的性能对比报告
