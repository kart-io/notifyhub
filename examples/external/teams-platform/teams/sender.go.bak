// Package teams provides a Microsoft Teams platform for NotifyHub
// This demonstrates creating external platforms for enterprise communication tools
package teams

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/kart-io/notifyhub/pkg/notifyhub/platform"
)

// TeamsSender implements the ExternalSender interface for Microsoft Teams webhooks
type TeamsSender struct {
	webhookURL string
	timeout    time.Duration
	client     *http.Client
}

// NewTeamsSender creates a new Microsoft Teams sender
func NewTeamsSender(config map[string]interface{}) (platform.ExternalSender, error) {
	webhookURL, ok := config["webhook_url"].(string)
	if !ok || webhookURL == "" {
		return nil, fmt.Errorf("webhook_url is required for Teams platform")
	}

	sender := &TeamsSender{
		webhookURL: webhookURL,
		timeout:    30 * time.Second,
	}

	// Configure optional settings
	if timeout, ok := config["timeout"].(time.Duration); ok {
		sender.timeout = timeout
	}

	// Create HTTP client
	sender.client = &http.Client{
		Timeout: sender.timeout,
	}

	return sender, nil
}

// Name returns the platform name
func (t *TeamsSender) Name() string {
	return "teams"
}

// Send sends a message to Microsoft Teams
func (t *TeamsSender) Send(ctx context.Context, msg *platform.Message, targets []platform.Target) ([]*platform.SendResult, error) {
	results := make([]*platform.SendResult, len(targets))

	for i, target := range targets {
		startTime := time.Now()
		result := &platform.SendResult{
			Target:  target,
			Success: false,
		}

		// Validate target
		if err := t.ValidateTarget(target); err != nil {
			result.Error = err.Error()
			results[i] = result
			continue
		}

		// Build Teams payload
		payload, err := t.buildTeamsPayload(msg, target)
		if err != nil {
			result.Error = fmt.Sprintf("failed to build payload: %v", err)
			results[i] = result
			continue
		}

		// Send to Teams
		if err := t.sendToTeams(ctx, payload); err != nil {
			result.Error = err.Error()
		} else {
			result.Success = true
			result.MessageID = fmt.Sprintf("teams_%d", time.Now().UnixNano())
			result.Response = "Message sent to Teams"
		}

		// Set metadata
		result.Metadata = map[string]interface{}{
			"duration":     time.Since(startTime).Milliseconds(),
			"webhook_url":  t.webhookURL,
			"card_type":    "MessageCard",
		}

		results[i] = result
	}

	return results, nil
}

// ValidateTarget validates a target for Teams
func (t *TeamsSender) ValidateTarget(target platform.Target) error {
	switch target.Type {
	case "webhook", "teams":
		// Valid target types for Teams
	default:
		return fmt.Errorf("teams supports webhook and teams targets, got %s", target.Type)
	}

	return nil
}

// GetCapabilities returns Teams platform capabilities
func (t *TeamsSender) GetCapabilities() platform.Capabilities {
	return platform.Capabilities{
		Name:                 "teams",
		SupportedTargetTypes: []string{"webhook", "teams"},
		SupportedFormats:     []string{"text", "markdown"},
		MaxMessageSize:       28000, // Teams limit
		SupportsScheduling:   false,
		SupportsAttachments:  false,
		SupportsMentions:     true,
		SupportsRichContent:  true,
		RequiredSettings:     []string{"webhook_url"},
	}
}

// IsHealthy checks if Teams webhook is accessible
func (t *TeamsSender) IsHealthy(ctx context.Context) error {
	if t.webhookURL == "" {
		return fmt.Errorf("Teams webhook URL is not configured")
	}

	// Teams webhooks don't support health check pings
	// We'll just validate the URL format
	if len(t.webhookURL) < 10 {
		return fmt.Errorf("Teams webhook URL appears invalid")
	}

	return nil
}

// Close cleans up resources
func (t *TeamsSender) Close() error {
	return nil
}

// TeamsMessageCard represents a Microsoft Teams MessageCard payload
type TeamsMessageCard struct {
	Type       string                 `json:"@type"`
	Context    string                 `json:"@context"`
	Summary    string                 `json:"summary,omitempty"`
	Title      string                 `json:"title,omitempty"`
	Text       string                 `json:"text,omitempty"`
	ThemeColor string                 `json:"themeColor,omitempty"`
	Sections   []TeamsSection         `json:"sections,omitempty"`
	Actions    []TeamsAction          `json:"potentialAction,omitempty"`
}

// TeamsSection represents a section in Teams MessageCard
type TeamsSection struct {
	Title             string       `json:"activityTitle,omitempty"`
	Subtitle          string       `json:"activitySubtitle,omitempty"`
	Text              string       `json:"activityText,omitempty"`
	Image             string       `json:"activityImage,omitempty"`
	Facts             []TeamsFact  `json:"facts,omitempty"`
	Markdown          bool         `json:"markdown,omitempty"`
}

// TeamsFact represents a fact in Teams section
type TeamsFact struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// TeamsAction represents an action in Teams MessageCard
type TeamsAction struct {
	Type    string                 `json:"@type"`
	Name    string                 `json:"name"`
	Target  []string              `json:"targets,omitempty"`
	Actions []TeamsActionElement   `json:"actions,omitempty"`
}

// TeamsActionElement represents an action element
type TeamsActionElement struct {
	Type   string `json:"@type"`
	Name   string `json:"name"`
	Target string `json:"target"`
}

// buildTeamsPayload builds the Teams webhook payload
func (t *TeamsSender) buildTeamsPayload(msg *platform.Message, target platform.Target) (TeamsMessageCard, error) {
	card := TeamsMessageCard{
		Type:       "MessageCard",
		Context:    "http://schema.org/extensions",
		Summary:    msg.Title,
		Title:      msg.Title,
		Text:       msg.Body,
		ThemeColor: t.getColorForPriority(msg.Priority),
	}

	// Check for custom Teams data
	if teamsData, ok := msg.PlatformData["teams_card"]; ok {
		if customCard, ok := teamsData.(TeamsMessageCard); ok {
			return customCard, nil
		}
		if customCard, ok := teamsData.(map[string]interface{}); ok {
			cardBytes, _ := json.Marshal(customCard)
			json.Unmarshal(cardBytes, &card)
			return card, nil
		}
	}

	// Build sections with metadata and variables
	var sections []TeamsSection

	// Main content section
	if msg.Body != "" || len(msg.Metadata) > 0 || len(msg.Variables) > 0 {
		section := TeamsSection{
			Title:    msg.Title,
			Text:     msg.Body,
			Markdown: msg.Format == "markdown",
		}

		// Add metadata as facts
		var facts []TeamsFact
		for key, value := range msg.Metadata {
			facts = append(facts, TeamsFact{
				Name:  key,
				Value: fmt.Sprintf("%v", value),
			})
		}

		// Add variables as facts
		for key, value := range msg.Variables {
			facts = append(facts, TeamsFact{
				Name:  key,
				Value: fmt.Sprintf("%v", value),
			})
		}

		if len(facts) > 0 {
			section.Facts = facts
		}

		sections = append(sections, section)
	}

	// Check for custom sections
	if customSections, ok := msg.PlatformData["teams_sections"].([]TeamsSection); ok {
		sections = append(sections, customSections...)
	}

	if len(sections) > 0 {
		card.Sections = sections
	}

	// Check for custom actions
	if customActions, ok := msg.PlatformData["teams_actions"].([]TeamsAction); ok {
		card.Actions = customActions
	}

	return card, nil
}

// getColorForPriority returns color based on message priority
func (t *TeamsSender) getColorForPriority(priority int) string {
	switch {
	case priority >= 8: // Urgent
		return "ff0000" // Red
	case priority >= 5: // Alert
		return "ffa500" // Orange
	case priority >= 3: // Normal
		return "00ff00" // Green
	default: // Low
		return "808080" // Gray
	}
}

// sendToTeams sends the payload to Teams webhook
func (t *TeamsSender) sendToTeams(ctx context.Context, card TeamsMessageCard) error {
	payloadBytes, err := json.Marshal(card)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", t.webhookURL, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := t.client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("Teams returned status %d", resp.StatusCode)
	}

	return nil
}