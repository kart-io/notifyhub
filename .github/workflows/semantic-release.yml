name: Semantic Release

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      version:
        description: 'Specific version to release (e.g., v1.2.3) or leave empty for auto'
        required: false
        type: string
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: read

jobs:
  semantic-release:
    name: Semantic Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest tag
        id: get_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Latest tag: $LATEST_TAG"

      - name: Analyze commits
        id: analyze
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"

          # Get commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          fi

          # Analyze commit types
          BREAKING=0
          FEAT=0
          FIX=0
          OTHER=0

          while IFS= read -r commit; do
            if echo "$commit" | grep -qiE "^(feat|feature|breaking).*!:|^BREAKING CHANGE:"; then
              BREAKING=$((BREAKING + 1))
            elif echo "$commit" | grep -qiE "^(feat|feature)(\(.*\))?:"; then
              FEAT=$((FEAT + 1))
            elif echo "$commit" | grep -qiE "^fix(\(.*\))?:"; then
              FIX=$((FIX + 1))
            else
              OTHER=$((OTHER + 1))
            fi
          done <<< "$COMMITS"

          echo "breaking_changes=$BREAKING" >> $GITHUB_OUTPUT
          echo "features=$FEAT" >> $GITHUB_OUTPUT
          echo "fixes=$FIX" >> $GITHUB_OUTPUT
          echo "other=$OTHER" >> $GITHUB_OUTPUT

          echo "ðŸ“Š Commit Analysis:"
          echo "  - Breaking Changes: $BREAKING"
          echo "  - Features: $FEAT"
          echo "  - Fixes: $FIX"
          echo "  - Other: $OTHER"

      - name: Determine version
        id: version
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Manual version override
          if [ -n "${{ github.event.inputs.version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.version }}"
          else
            # Semantic versioning based on commits
            BREAKING=${{ steps.analyze.outputs.breaking_changes }}
            FEAT=${{ steps.analyze.outputs.features }}
            FIX=${{ steps.analyze.outputs.fixes }}

            if [ $BREAKING -gt 0 ]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major"
            elif [ $FEAT -gt 0 ]; then
              MINOR=$((MINOR + 1))
              PATCH=0
              BUMP_TYPE="minor"
            elif [ $FIX -gt 0 ]; then
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch"
            else
              # No semantic commits, skip release
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "â­ï¸ No semantic commits found, skipping release"
              exit 0
            fi

            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "bump_type=${BUMP_TYPE:-manual}" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ New version: $NEW_VERSION"

      - name: Check if tag exists
        id: check_tag
        if: steps.version.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âŒ Tag $NEW_VERSION already exists"
            exit 1
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Tag $NEW_VERSION is available"
          fi

      - name: Generate detailed changelog
        id: changelog
        if: steps.version.outputs.should_release == 'true'
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          echo "# Release $NEW_VERSION" > CHANGELOG.md
          echo "" >> CHANGELOG.md

          # Get commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s|%h|%an" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"%s|%h|%an" --no-merges)
          fi

          # Categorize commits
          echo "## ðŸš¨ Breaking Changes" > breaking.txt
          echo "## âœ¨ Features" > features.txt
          echo "## ðŸ› Bug Fixes" > fixes.txt
          echo "## ðŸ“š Documentation" > docs.txt
          echo "## ðŸ—ï¸ Chores" > chores.txt
          echo "## ðŸŽ¨ Styles" > styles.txt
          echo "## â™»ï¸ Refactors" > refactor.txt
          echo "## âš¡ Performance" > perf.txt
          echo "## âœ… Tests" > tests.txt
          echo "## ðŸ”§ Other" > other.txt

          while IFS='|' read -r subject hash author; do
            LINE="- $subject ([$hash](https://github.com/${{ github.repository }}/commit/$hash)) by @$author"

            if echo "$subject" | grep -qiE "^(feat|feature|breaking).*!:|^BREAKING CHANGE:"; then
              echo "$LINE" >> breaking.txt
            elif echo "$subject" | grep -qiE "^(feat|feature)(\(.*\))?:"; then
              echo "$LINE" >> features.txt
            elif echo "$subject" | grep -qiE "^fix(\(.*\))?:"; then
              echo "$LINE" >> fixes.txt
            elif echo "$subject" | grep -qiE "^docs(\(.*\))?:"; then
              echo "$LINE" >> docs.txt
            elif echo "$subject" | grep -qiE "^chore(\(.*\))?:"; then
              echo "$LINE" >> chores.txt
            elif echo "$subject" | grep -qiE "^style(\(.*\))?:"; then
              echo "$LINE" >> styles.txt
            elif echo "$subject" | grep -qiE "^refactor(\(.*\))?:"; then
              echo "$LINE" >> refactor.txt
            elif echo "$subject" | grep -qiE "^perf(\(.*\))?:"; then
              echo "$LINE" >> perf.txt
            elif echo "$subject" | grep -qiE "^test(\(.*\))?:"; then
              echo "$LINE" >> tests.txt
            else
              echo "$LINE" >> other.txt
            fi
          done <<< "$COMMITS"

          # Append sections with content
          for file in breaking.txt features.txt fixes.txt docs.txt chores.txt styles.txt refactor.txt perf.txt tests.txt other.txt; do
            if [ $(wc -l < "$file") -gt 1 ]; then
              cat "$file" >> CHANGELOG.md
              echo "" >> CHANGELOG.md
            fi
          done

          # Add compare link
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${NEW_VERSION}" >> CHANGELOG.md
          fi

          # Output changelog
          CHANGELOG=$(cat CHANGELOG.md)
          {
            echo "changelog<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "ðŸ“ Changelog generated"

      - name: Create Git tag
        if: steps.version.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          # Create tag message
          cat > tag_message.txt <<EOF
          Release $NEW_VERSION

          ${{ steps.changelog.outputs.changelog }}

          ---
          ðŸ¤– Automated release by GitHub Actions
          EOF

          # Create and push tag
          git tag -a "$NEW_VERSION" -F tag_message.txt
          git push origin "$NEW_VERSION"

          echo "âœ… Tag $NEW_VERSION created and pushed"

      - name: Create GitHub Release
        if: steps.version.outputs.should_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          IS_PRERELEASE="${{ github.event.inputs.prerelease || 'false' }}"

          gh release create "$NEW_VERSION" \
            --title "Release $NEW_VERSION" \
            --notes "${{ steps.changelog.outputs.changelog }}" \
            --latest \
            $([ "$IS_PRERELEASE" = "true" ] && echo "--prerelease" || echo "")

          echo "ðŸŽ‰ GitHub Release created"

      - name: Generate summary
        if: steps.version.outputs.should_release == 'true'
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ðŸŽ‰ Release ${{ steps.version.outputs.new_version }}

          ### ðŸ“Š Release Information
          - **Previous Version**: ${{ steps.get_tag.outputs.latest_tag }}
          - **New Version**: ${{ steps.version.outputs.new_version }}
          - **Bump Type**: ${{ steps.version.outputs.bump_type }}
          - **Pre-release**: ${{ github.event.inputs.prerelease || 'false' }}

          ### ðŸ“ˆ Commit Statistics
          - Breaking Changes: ${{ steps.analyze.outputs.breaking_changes }}
          - Features: ${{ steps.analyze.outputs.features }}
          - Bug Fixes: ${{ steps.analyze.outputs.fixes }}
          - Other: ${{ steps.analyze.outputs.other }}

          ### ðŸ“ Changelog
          ${{ steps.changelog.outputs.changelog }}

          ### ðŸ”— Links
          - [Release Page](https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.new_version }})
          - [Comparison](https://github.com/${{ github.repository }}/compare/${{ steps.get_tag.outputs.latest_tag }}...${{ steps.version.outputs.new_version }})
          EOF

      - name: Skip summary
        if: steps.version.outputs.should_release != 'true'
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## â­ï¸ Release Skipped

          No semantic commits found since the last release.

          ### Commit Guidelines
          To trigger a release, use conventional commit messages:
          - \`feat: add new feature\` - triggers minor version bump
          - \`fix: resolve bug\` - triggers patch version bump
          - \`feat!: breaking change\` - triggers major version bump

          **Latest Tag**: ${{ steps.get_tag.outputs.latest_tag }}
          EOF
