
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>elegant_api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kart-io/notifyhub/examples/elegant_api/main.go (0.0%)</option>
				
				<option value="file1">github.com/kart-io/notifyhub/internal/platform/email/sender.go (0.0%)</option>
				
				<option value="file2">github.com/kart-io/notifyhub/internal/platform/feishu/sender.go (0.0%)</option>
				
				<option value="file3">github.com/kart-io/notifyhub/internal/platform/interface.go (100.0%)</option>
				
				<option value="file4">github.com/kart-io/notifyhub/internal/platform/manager.go (59.5%)</option>
				
				<option value="file5">github.com/kart-io/notifyhub/internal/platform/sms/sender.go (0.0%)</option>
				
				<option value="file6">github.com/kart-io/notifyhub/internal/platform/testutil.go (44.1%)</option>
				
				<option value="file7">github.com/kart-io/notifyhub/pkg/notifyhub/config.go (0.0%)</option>
				
				<option value="file8">github.com/kart-io/notifyhub/pkg/notifyhub/errors.go (36.5%)</option>
				
				<option value="file9">github.com/kart-io/notifyhub/pkg/notifyhub/hub.go (77.4%)</option>
				
				<option value="file10">github.com/kart-io/notifyhub/pkg/notifyhub/message.go (43.9%)</option>
				
				<option value="file11">github.com/kart-io/notifyhub/pkg/notifyhub/options.go (11.2%)</option>
				
				<option value="file12">github.com/kart-io/notifyhub/pkg/notifyhub/receipt.go (0.0%)</option>
				
				<option value="file13">github.com/kart-io/notifyhub/pkg/notifyhub/target.go (42.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main demonstrates the new elegant API for NotifyHub
package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/kart-io/notifyhub/pkg/notifyhub"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== NotifyHub Elegant API Demo ===")

        // Initialize hub with configuration
        hub, err := notifyhub.NewHub(
                notifyhub.WithFeishuFromMap(map[string]interface{}{
                        "webhook_url": "https://open.feishu.cn/open-apis/bot/v2/hook/xxxxxxxx",
                        "secret":      "xxxxxxxx",
                }),
                notifyhub.WithEmailFromMap(map[string]interface{}{
                        "smtp_host":     "smtp.gmail.com",
                        "smtp_port":     587,
                        "smtp_username": "your@gmail.com",
                        "smtp_password": "your-password",
                        "smtp_from":     "your@gmail.com",
                        "smtp_tls":      true,
                }),
                notifyhub.WithSMSFromMap(map[string]interface{}{
                        "provider": "twilio",
                        "api_key":  "your-twilio-api-key",
                        "from":     "+1234567890",
                }),
                notifyhub.WithTimeout(10*time.Second),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create hub: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := hub.Close(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close hub: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">ctx := context.Background()

        // Example 1: Simple text message to multiple platforms
        fmt.Println("\n--- Example 1: Simple text message ---")
        receipt, err := hub.Send(ctx, notifyhub.NewMessage("Task Completed").
                WithText("Your data processing task has been completed successfully.").
                ToEmail("user@example.com").
                ToFeishu("oc_xxxxxxxx"). // Feishu user ID
                ToPhone("+1234567890").
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Send result: %s, Successful: %d, Failed: %d\n",
                        receipt.Status, receipt.Successful, receipt.Failed)
        }</span>

        // Example 2: Rich Feishu card message
        <span class="cov0" title="0">fmt.Println("\n--- Example 2: Feishu card message ---")
        cardContent := map[string]interface{}{
                "config": map[string]interface{}{
                        "wide_screen_mode": true,
                },
                "elements": []map[string]interface{}{
                        {
                                "tag": "div",
                                "text": map[string]interface{}{
                                        "content": "**New Task Assigned**\nPlease check your task list.",
                                        "tag":     "lark_md",
                                },
                        },
                },
        }

        receipt, err = hub.Send(ctx, notifyhub.NewAlert("New Task Assigned").
                WithFeishuCard(cardContent).
                WithFeishuMentions("oc_xxxxxxxx").
                ToFeishuGroup("oc_xxxxxxxx"). // Feishu group ID
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Send result: %s\n", receipt.Status)
        }</span>

        // Example 3: HTML email with CC/BCC
        <span class="cov0" title="0">fmt.Println("\n--- Example 3: HTML email with CC/BCC ---")
        htmlContent := `
        &lt;h2 style="color: #2c3e50;"&gt;System Alert&lt;/h2&gt;
        &lt;p&gt;Dear team,&lt;/p&gt;
        &lt;p&gt;The following system alert has been triggered:&lt;/p&gt;
        &lt;div style="background-color: #f8f9fa; padding: 15px; border-left: 4px solid #007bff;"&gt;
                &lt;strong&gt;High CPU Usage Detected&lt;/strong&gt;&lt;br&gt;
                Server: web-server-01&lt;br&gt;
                CPU Usage: 95%&lt;br&gt;
                Time: ` + time.Now().Format("2006-01-02 15:04:05") + `
        &lt;/div&gt;
        &lt;p&gt;Please investigate immediately.&lt;/p&gt;
        &lt;p&gt;Best regards,&lt;br&gt;Monitoring System&lt;/p&gt;
        `

        receipt, err = hub.Send(ctx, notifyhub.NewUrgent("System Alert: High CPU Usage").
                WithHTML(htmlContent).
                WithEmailCC("manager@example.com", "devops@example.com").
                WithEmailPriority("high").
                ToEmail("admin@example.com").
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Send result: %s\n", receipt.Status)
        }</span>

        // Example 4: SMS with template variables
        <span class="cov0" title="0">fmt.Println("\n--- Example 4: SMS with template ---")
        receipt, err = hub.Send(ctx, notifyhub.NewMessage("Order Confirmation").
                WithSMSTemplate("order_confirmation").
                WithSMSVariables(map[string]interface{}{
                        "order_id":    "ORD-12345",
                        "total":       "$99.99",
                        "customer":    "John Doe",
                        "delivery_at": "2024-01-15 14:30",
                }).
                ToPhone("+1234567890").
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Send result: %s\n", receipt.Status)
        }</span>

        // Example 5: Scheduled message
        <span class="cov0" title="0">fmt.Println("\n--- Example 5: Scheduled message ---")
        scheduleTime := time.Now().Add(5 * time.Minute)
        receipt, err = hub.Send(ctx, notifyhub.NewMessage("Reminder").
                WithText("Don't forget about your meeting at 3 PM.").
                ScheduleAt(scheduleTime).
                ToEmail("user@example.com").
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Scheduled message: %s, will be sent at %s\n",
                        receipt.MessageID, scheduleTime.Format("15:04:05"))
        }</span>

        // Example 6: Multi-target message with metadata
        <span class="cov0" title="0">fmt.Println("\n--- Example 6: Multi-target with metadata ---")
        message := notifyhub.NewMessage("Deployment Complete").
                WithMarkdown("## Deployment Status\n\n✅ **SUCCESS**: Version v2.1.0 deployed to production\n\n- **Deployment ID**: dep-789\n- **Duration**: 3m 45s\n- **Affected Services**: api, web, worker").
                WithMetadata("deployment_id", "dep-789").
                WithMetadata("version", "v2.1.0").
                WithVariable("service_count", 3).
                ToFeishuGroup("oc_xxxxxxxx").
                ToEmail("devops@example.com").
                Build()

        receipt, err = hub.Send(ctx, message)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Send result: %s, Message ID: %s\n", receipt.Status, receipt.MessageID)

                // Show detailed results
                for _, result := range receipt.Results </span><span class="cov0" title="0">{
                        fmt.Printf("  Platform: %s, Target: %s, Success: %v\n",
                                result.Platform, result.Target.Value, result.Success)
                }</span>
        }

        // Example 7: Async sending
        <span class="cov0" title="0">fmt.Println("\n--- Example 7: Async sending ---")
        asyncReceipt, err := hub.SendAsync(ctx, notifyhub.NewMessage("Background Task").
                WithText("This message is sent asynchronously.").
                ToEmail("user@example.com").
                Build(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Async send failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Async send queued: %s, Status: %s\n",
                        asyncReceipt.MessageID, asyncReceipt.Status)
        }</span>

        // Example 8: Health check
        <span class="cov0" title="0">fmt.Println("\n--- Example 8: Health check ---")
        health, err := hub.Health(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Health check failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Overall health: %s\n", health.Status)
                for platform, status := range health.Platforms </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %s\n", platform, status.Status)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\n=== Demo completed ===")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package email implements the Email Sender for SMTP-based email notifications
// This integrates all Email-specific logic from the former adapter.go, platform.go, and builder.go
package email

import (
        "context"
        "fmt"
        "net/smtp"
        "time"

        "github.com/kart-io/notifyhub/internal/platform"
)

// EmailSender implements the platform.Sender interface for email notifications
type EmailSender struct {
        name   string
        config EmailConfig
        auth   smtp.Auth
}

// EmailConfig holds email configuration
type EmailConfig struct {
        SMTPHost     string        `json:"smtp_host"`
        SMTPPort     int           `json:"smtp_port"`
        SMTPUsername string        `json:"smtp_username"`
        SMTPPassword string        `json:"smtp_password"`
        SMTPFrom     string        `json:"smtp_from"`
        SMTPTLS      bool          `json:"smtp_tls"`
        SMTPSSL      bool          `json:"smtp_ssl"`
        Timeout      time.Duration `json:"timeout"`
}

// NewEmailSender creates a new email sender
func NewEmailSender(config map[string]interface{}) (platform.Sender, error) <span class="cov0" title="0">{
        emailConfig, err := parseEmailConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid email configuration: %w", err)
        }</span>

        // Setup SMTP authentication
        <span class="cov0" title="0">var auth smtp.Auth
        if emailConfig.SMTPUsername != "" &amp;&amp; emailConfig.SMTPPassword != "" </span><span class="cov0" title="0">{
                auth = smtp.PlainAuth("", emailConfig.SMTPUsername, emailConfig.SMTPPassword, emailConfig.SMTPHost)
        }</span>

        <span class="cov0" title="0">return &amp;EmailSender{
                name:   "email",
                config: emailConfig,
                auth:   auth,
        }, nil</span>
}

// Name returns the platform name
func (e *EmailSender) Name() string <span class="cov0" title="0">{
        return e.name
}</span>

// Send sends an email message to the specified targets
func (e *EmailSender) Send(ctx context.Context, msg *platform.InternalMessage, targets []platform.InternalTarget) ([]*platform.SendResult, error) <span class="cov0" title="0">{
        results := make([]*platform.SendResult, len(targets))

        for i, target := range targets </span><span class="cov0" title="0">{
                startTime := time.Now()
                result := platform.NewSendResult(target, false)

                // Validate target
                if err := e.ValidateTarget(target); err != nil </span><span class="cov0" title="0">{
                        result.Error = err.Error()
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Build email content
                <span class="cov0" title="0">emailContent, err := e.buildEmailContent(msg, target)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to build email content: %v", err)
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Send email
                <span class="cov0" title="0">err = e.sendEmail(ctx, target.Value, emailContent)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to send email: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        result.Success = true
                        result.MessageID = fmt.Sprintf("email_%d", time.Now().UnixNano())
                }</span>

                <span class="cov0" title="0">result.SetDuration(time.Since(startTime))
                results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// ValidateTarget validates an email target
func (e *EmailSender) ValidateTarget(target platform.InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "email" </span><span class="cov0" title="0">{
                return fmt.Errorf("email sender only supports email targets, got %s", target.Type)
        }</span>

        <span class="cov0" title="0">if target.Value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("email address cannot be empty")
        }</span>

        // Basic email validation
        <span class="cov0" title="0">if !isValidEmail(target.Value) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid email address: %s", target.Value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCapabilities returns the email platform capabilities
func (e *EmailSender) GetCapabilities() platform.PlatformCapabilities <span class="cov0" title="0">{
        return platform.PlatformCapabilities{
                Name:                 "email",
                SupportedTargetTypes: []string{"email"},
                SupportedFormats:     []string{"text", "html"},
                MaxMessageSize:       25 * 1024 * 1024, // 25MB (typical email limit)
                SupportsScheduling:   false,
                SupportsAttachments:  true,
                SupportsMentions:     false,
                SupportsRichContent:  true,
                RequiredSettings:     []string{"smtp_host", "smtp_port", "smtp_from"},
        }
}</span>

// IsHealthy checks if the email sender is healthy
func (e *EmailSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{
        // Try to connect to SMTP server
        addr := fmt.Sprintf("%s:%d", e.config.SMTPHost, e.config.SMTPPort)

        // Use context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, e.config.Timeout)
        defer cancel()

        // Simple connection test
        done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                conn, err := smtp.Dial(addr)
                if err != nil </span><span class="cov0" title="0">{
                        done &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">defer conn.Close()
                done &lt;- nil</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                return err</span>
        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                return fmt.Errorf("smtp connection timeout")</span>
        }
}

// Close cleans up the email sender resources
func (e *EmailSender) Close() error <span class="cov0" title="0">{
        // Email sender doesn't hold persistent connections
        return nil
}</span>

// buildEmailContent builds the email content from the internal message
func (e *EmailSender) buildEmailContent(msg *platform.InternalMessage, target platform.InternalTarget) (string, error) <span class="cov0" title="0">{
        var content string

        // Build headers
        content += fmt.Sprintf("From: %s\r\n", e.config.SMTPFrom)
        content += fmt.Sprintf("To: %s\r\n", target.Value)

        // Add CC and BCC from platform data
        if ccList, ok := msg.PlatformData["email_cc"].([]string); ok &amp;&amp; len(ccList) &gt; 0 </span><span class="cov0" title="0">{
                content += fmt.Sprintf("Cc: %s\r\n", joinEmails(ccList))
        }</span>

        // Subject
        <span class="cov0" title="0">subject := msg.Title
        if subject == "" </span><span class="cov0" title="0">{
                subject = "Notification"
        }</span>
        <span class="cov0" title="0">content += fmt.Sprintf("Subject: %s\r\n", subject)

        // Priority
        if priority, ok := msg.PlatformData["email_priority"].(string); ok </span><span class="cov0" title="0">{
                switch priority </span>{
                case "high":<span class="cov0" title="0">
                        content += "X-Priority: 1\r\n"</span>
                case "low":<span class="cov0" title="0">
                        content += "X-Priority: 5\r\n"</span>
                }
        }

        // Content-Type based on format
        <span class="cov0" title="0">if msg.Format == "html" </span><span class="cov0" title="0">{
                content += "MIME-Version: 1.0\r\n"
                content += "Content-Type: text/html; charset=UTF-8\r\n"
        }</span> else<span class="cov0" title="0"> {
                content += "MIME-Version: 1.0\r\n"
                content += "Content-Type: text/plain; charset=UTF-8\r\n"
        }</span>

        <span class="cov0" title="0">content += "\r\n" // Empty line between headers and body

        // Body
        body := msg.Body
        if body == "" </span><span class="cov0" title="0">{
                body = subject // Use subject as body if body is empty
        }</span>

        <span class="cov0" title="0">content += body

        // TODO: Handle attachments from msg.PlatformData["email_attachments"]

        return content, nil</span>
}

// sendEmail sends the email using SMTP
func (e *EmailSender) sendEmail(ctx context.Context, to, content string) error <span class="cov0" title="0">{
        addr := fmt.Sprintf("%s:%d", e.config.SMTPHost, e.config.SMTPPort)

        // Extract recipients (to, cc, bcc from content)
        recipients := []string{to}
        // TODO: Parse CC and BCC from content and add to recipients

        // Use context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, e.config.Timeout)
        defer cancel()

        // Send email with timeout
        done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                err := smtp.SendMail(addr, e.auth, e.config.SMTPFrom, recipients, []byte(content))
                done &lt;- err
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                return err</span>
        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                return fmt.Errorf("email send timeout")</span>
        }
}

// parseEmailConfig parses email configuration from map
func parseEmailConfig(config map[string]interface{}) (EmailConfig, error) <span class="cov0" title="0">{
        emailConfig := EmailConfig{
                Timeout: 30 * time.Second, // Default timeout
                SMTPTLS: true,             // Default to TLS
        }

        // Required fields
        if host, ok := config["smtp_host"].(string); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPHost = host
        }</span> else<span class="cov0" title="0"> {
                return emailConfig, fmt.Errorf("smtp_host is required")
        }</span>

        <span class="cov0" title="0">if port, ok := config["smtp_port"].(int); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPPort = port
        }</span> else<span class="cov0" title="0"> {
                return emailConfig, fmt.Errorf("smtp_port is required")
        }</span>

        <span class="cov0" title="0">if from, ok := config["smtp_from"].(string); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPFrom = from
        }</span> else<span class="cov0" title="0"> {
                return emailConfig, fmt.Errorf("smtp_from is required")
        }</span>

        // Optional fields
        <span class="cov0" title="0">if username, ok := config["smtp_username"].(string); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPUsername = username
        }</span>

        <span class="cov0" title="0">if password, ok := config["smtp_password"].(string); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPPassword = password
        }</span>

        <span class="cov0" title="0">if tls, ok := config["smtp_tls"].(bool); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPTLS = tls
        }</span>

        <span class="cov0" title="0">if ssl, ok := config["smtp_ssl"].(bool); ok </span><span class="cov0" title="0">{
                emailConfig.SMTPSSL = ssl
        }</span>

        <span class="cov0" title="0">if timeout, ok := config["timeout"].(time.Duration); ok </span><span class="cov0" title="0">{
                emailConfig.Timeout = timeout
        }</span>

        <span class="cov0" title="0">return emailConfig, nil</span>
}

// isValidEmail performs basic email validation
func isValidEmail(email string) bool <span class="cov0" title="0">{
        // Basic validation - contains @ and .
        atCount := 0
        dotAfterAt := false
        atPos := -1

        for i, c := range email </span><span class="cov0" title="0">{
                if c == '@' </span><span class="cov0" title="0">{
                        atCount++
                        atPos = i
                }</span> else<span class="cov0" title="0"> if c == '.' &amp;&amp; atPos &gt; 0 &amp;&amp; i &gt; atPos </span><span class="cov0" title="0">{
                        dotAfterAt = true
                }</span>
        }

        <span class="cov0" title="0">return atCount == 1 &amp;&amp; dotAfterAt &amp;&amp; len(email) &gt; 5</span>
}

// joinEmails joins email addresses with commas
func joinEmails(emails []string) string <span class="cov0" title="0">{
        if len(emails) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">result := emails[0]
        for i := 1; i &lt; len(emails); i++ </span><span class="cov0" title="0">{
                result += ", " + emails[i]
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package feishu implements the Feishu Sender for Feishu/Lark notifications
// This integrates all Feishu-specific logic including webhooks, cards, and user mentions
package feishu

import (
        "bytes"
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"

        "github.com/kart-io/notifyhub/internal/platform"
)

// FeishuSender implements the platform.Sender interface for Feishu notifications
type FeishuSender struct {
        name   string
        config FeishuConfig
        client *http.Client
}

// FeishuConfig holds Feishu configuration
type FeishuConfig struct {
        WebhookURL string        `json:"webhook_url"`
        Secret     string        `json:"secret"`
        Timeout    time.Duration `json:"timeout"`
}

// FeishuMessage represents a Feishu message payload
type FeishuMessage struct {
        Timestamp string      `json:"timestamp"`
        Sign      string      `json:"sign,omitempty"`
        MsgType   string      `json:"msg_type"`
        Content   interface{} `json:"content"`
}

// FeishuTextContent represents text message content
type FeishuTextContent struct {
        Text string `json:"text"`
}

// FeishuCardContent represents card message content
type FeishuCardContent struct {
        Card interface{} `json:"card"`
}

// FeishuResponse represents Feishu API response
type FeishuResponse struct {
        Code int         `json:"code"`
        Msg  string      `json:"msg"`
        Data interface{} `json:"data,omitempty"`
}

// NewFeishuSender creates a new Feishu sender
func NewFeishuSender(config map[string]interface{}) (platform.Sender, error) <span class="cov0" title="0">{
        feishuConfig, err := parseFeishuConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid feishu configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;FeishuSender{
                name:   "feishu",
                config: feishuConfig,
                client: &amp;http.Client{
                        Timeout: feishuConfig.Timeout,
                },
        }, nil</span>
}

// Name returns the platform name
func (f *FeishuSender) Name() string <span class="cov0" title="0">{
        return f.name
}</span>

// Send sends a Feishu message to the specified targets
func (f *FeishuSender) Send(ctx context.Context, msg *platform.InternalMessage, targets []platform.InternalTarget) ([]*platform.SendResult, error) <span class="cov0" title="0">{
        results := make([]*platform.SendResult, len(targets))

        for i, target := range targets </span><span class="cov0" title="0">{
                startTime := time.Now()
                result := platform.NewSendResult(target, false)

                // Validate target
                if err := f.ValidateTarget(target); err != nil </span><span class="cov0" title="0">{
                        result.Error = err.Error()
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Build Feishu message
                <span class="cov0" title="0">feishuMsg, err := f.buildFeishuMessage(msg, target)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to build feishu message: %v", err)
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Send message
                <span class="cov0" title="0">response, err := f.sendMessage(ctx, feishuMsg)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to send feishu message: %v", err)
                }</span> else<span class="cov0" title="0"> if response.Code != 0 </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("feishu API error: %s (code: %d)", response.Msg, response.Code)
                }</span> else<span class="cov0" title="0"> {
                        result.Success = true
                        result.MessageID = fmt.Sprintf("feishu_%d", time.Now().UnixNano())
                        result.Response = response.Msg
                }</span>

                <span class="cov0" title="0">result.SetDuration(time.Since(startTime))
                results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// ValidateTarget validates a Feishu target
func (f *FeishuSender) ValidateTarget(target platform.InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "user" &amp;&amp; target.Type != "group" &amp;&amp; target.Type != "webhook" </span><span class="cov0" title="0">{
                return fmt.Errorf("feishu sender supports user, group, and webhook targets, got %s", target.Type)
        }</span>

        <span class="cov0" title="0">if target.Value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("target value cannot be empty")
        }</span>

        // Validate webhook URL format if it's a webhook target
        <span class="cov0" title="0">if target.Type == "webhook" </span><span class="cov0" title="0">{
                if len(target.Value) &lt; 10 || (target.Value[:4] != "http") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid webhook URL: %s", target.Value)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetCapabilities returns the Feishu platform capabilities
func (f *FeishuSender) GetCapabilities() platform.PlatformCapabilities <span class="cov0" title="0">{
        return platform.PlatformCapabilities{
                Name:                 "feishu",
                SupportedTargetTypes: []string{"user", "group", "webhook"},
                SupportedFormats:     []string{"text", "markdown", "card"},
                MaxMessageSize:       30 * 1024, // 30KB typical limit for Feishu
                SupportsScheduling:   false,
                SupportsAttachments:  false,
                SupportsMentions:     true,
                SupportsRichContent:  true,
                RequiredSettings:     []string{"webhook_url"},
                RateLimits: &amp;platform.RateLimitInfo{
                        RequestsPerSecond: 5,
                        RequestsPerMinute: 100,
                        BurstSize:         10,
                },
        }
}</span>

// IsHealthy checks if the Feishu sender is healthy
func (f *FeishuSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{
        // Create a simple test message
        testMsg := &amp;FeishuMessage{
                Timestamp: strconv.FormatInt(time.Now().Unix(), 10),
                MsgType:   "text",
                Content: FeishuTextContent{
                        Text: "Health check test",
                },
        }

        // Add signature if secret is configured
        if f.config.Secret != "" </span><span class="cov0" title="0">{
                testMsg.Sign = f.generateSignature(testMsg.Timestamp)
        }</span>

        // Convert to JSON
        <span class="cov0" title="0">payload, err := json.Marshal(testMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal test message: %w", err)
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", f.config.WebhookURL, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Send request (but don't actually send the test message by using a dry-run approach)
        // For health check, we just verify we can create a valid request
        return nil</span>
}

// Close cleans up the Feishu sender resources
func (f *FeishuSender) Close() error <span class="cov0" title="0">{
        // HTTP client doesn't need explicit cleanup
        return nil
}</span>

// buildFeishuMessage builds a Feishu message from the internal message
func (f *FeishuSender) buildFeishuMessage(msg *platform.InternalMessage, target platform.InternalTarget) (*FeishuMessage, error) <span class="cov0" title="0">{
        timestamp := strconv.FormatInt(time.Now().Unix(), 10)

        feishuMsg := &amp;FeishuMessage{
                Timestamp: timestamp,
        }

        // Add signature if secret is configured
        if f.config.Secret != "" </span><span class="cov0" title="0">{
                feishuMsg.Sign = f.generateSignature(timestamp)
        }</span>

        // Check if there's card content in platform data
        <span class="cov0" title="0">if cardContent, ok := msg.PlatformData["feishu_card"]; ok </span><span class="cov0" title="0">{
                feishuMsg.MsgType = "interactive"

                // Parse card content
                var card interface{}
                if cardStr, ok := cardContent.(string); ok </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(cardStr), &amp;card); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid card JSON: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        card = cardContent
                }</span>

                <span class="cov0" title="0">feishuMsg.Content = FeishuCardContent{
                        Card: card,
                }</span>
        } else<span class="cov0" title="0"> {
                // Text message
                feishuMsg.MsgType = "text"

                text := f.buildTextContent(msg)
                feishuMsg.Content = FeishuTextContent{
                        Text: text,
                }
        }</span>

        <span class="cov0" title="0">return feishuMsg, nil</span>
}

// buildTextContent builds text content with mentions and formatting
func (f *FeishuSender) buildTextContent(msg *platform.InternalMessage) string <span class="cov0" title="0">{
        text := ""

        // Add title if present
        if msg.Title != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("**%s**\n", msg.Title)
        }</span>

        // Add body
        <span class="cov0" title="0">if msg.Body != "" </span><span class="cov0" title="0">{
                text += msg.Body
        }</span>

        // Add mentions from platform data
        <span class="cov0" title="0">if mentions, ok := msg.PlatformData["feishu_mentions"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                for _, mention := range mentions </span><span class="cov0" title="0">{
                        if userID, ok := mention["user_id"].(string); ok </span><span class="cov0" title="0">{
                                text += fmt.Sprintf(" &lt;at user_id=\"%s\"&gt;&lt;/at&gt;", userID)
                        }</span>
                }
        }

        // Add mention all if specified
        <span class="cov0" title="0">if mentionAll, ok := msg.PlatformData["feishu_mention_all"].(bool); ok &amp;&amp; mentionAll </span><span class="cov0" title="0">{
                text += " &lt;at user_id=\"all\"&gt;所有人&lt;/at&gt;"
        }</span>

        <span class="cov0" title="0">return text</span>
}

// sendMessage sends the Feishu message
func (f *FeishuSender) sendMessage(ctx context.Context, msg *FeishuMessage) (*FeishuResponse, error) <span class="cov0" title="0">{
        // Convert message to JSON
        payload, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", f.config.WebhookURL, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Send request
        resp, err := f.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">var feishuResp FeishuResponse
        if err := json.Unmarshal(body, &amp;feishuResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;feishuResp, nil</span>
}

// generateSignature generates HMAC signature for Feishu webhook
func (f *FeishuSender) generateSignature(timestamp string) string <span class="cov0" title="0">{
        if f.config.Secret == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">stringToSign := fmt.Sprintf("%s\n%s", timestamp, f.config.Secret)
        h := hmac.New(sha256.New, []byte(stringToSign))
        return base64.StdEncoding.EncodeToString(h.Sum(nil))</span>
}

// parseFeishuConfig parses Feishu configuration from map
func parseFeishuConfig(config map[string]interface{}) (FeishuConfig, error) <span class="cov0" title="0">{
        feishuConfig := FeishuConfig{
                Timeout: 30 * time.Second, // Default timeout
        }

        // Required fields
        if webhookURL, ok := config["webhook_url"].(string); ok </span><span class="cov0" title="0">{
                feishuConfig.WebhookURL = webhookURL
        }</span> else<span class="cov0" title="0"> {
                return feishuConfig, fmt.Errorf("webhook_url is required")
        }</span>

        // Optional fields
        <span class="cov0" title="0">if secret, ok := config["secret"].(string); ok </span><span class="cov0" title="0">{
                feishuConfig.Secret = secret
        }</span>

        <span class="cov0" title="0">if timeout, ok := config["timeout"].(time.Duration); ok </span><span class="cov0" title="0">{
                feishuConfig.Timeout = timeout
        }</span>

        // Validate webhook URL
        <span class="cov0" title="0">if len(feishuConfig.WebhookURL) &lt; 10 || feishuConfig.WebhookURL[:4] != "http" </span><span class="cov0" title="0">{
                return feishuConfig, fmt.Errorf("invalid webhook_url format")
        }</span>

        <span class="cov0" title="0">return feishuConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package platform provides the interface and management for notification platform senders
// This defines the contract that all platform implementations must follow
package platform

import (
        "context"
        "time"
)

// Sender interface defines the contract that all platform notification senders must implement
// This is the core interface that bridges the dispatcher and actual platform implementations
type Sender interface {
        // Name returns the platform name (e.g., "feishu", "email", "sms")
        Name() string

        // Send sends a message to the specified targets and returns results
        Send(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error)

        // ValidateTarget validates a target for this platform
        ValidateTarget(target InternalTarget) error

        // GetCapabilities returns the capabilities of this platform
        GetCapabilities() PlatformCapabilities

        // IsHealthy checks if the platform is currently healthy and ready to send
        IsHealthy(ctx context.Context) error

        // Close gracefully shuts down the sender and cleans up resources
        Close() error
}

// InternalMessage represents a message in the internal format used by platform senders
// This is converted from the public API Message by the dispatcher
type InternalMessage struct {
        ID          string                 `json:"id"`
        Title       string                 `json:"title"`
        Body        string                 `json:"body"`
        Format      string                 `json:"format"` // "text", "markdown", "html"
        Priority    int                    `json:"priority"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
        Variables   map[string]interface{} `json:"variables,omitempty"`
        ScheduledAt *time.Time             `json:"scheduled_at,omitempty"`

        // Platform-specific data extracted from public message
        PlatformData map[string]interface{} `json:"platform_data,omitempty"`
}

// InternalTarget represents a target in the internal format
type InternalTarget struct {
        Type     string `json:"type"`     // "email", "user", "group", "webhook", "phone"
        Value    string `json:"value"`    // target identifier
        Platform string `json:"platform"` // platform name
}

// SendResult represents the result of sending to a single target
type SendResult struct {
        Target     InternalTarget    `json:"target"`
        Success    bool              `json:"success"`
        MessageID  string            `json:"message_id,omitempty"`
        Error      string            `json:"error,omitempty"`
        StatusCode int               `json:"status_code,omitempty"`
        Response   string            `json:"response,omitempty"`
        SentAt     time.Time         `json:"sent_at"`
        Duration   time.Duration     `json:"duration"`
        Metadata   map[string]string `json:"metadata,omitempty"`
}

// PlatformCapabilities describes what a platform can do
type PlatformCapabilities struct {
        Name                 string         `json:"name"`
        SupportedTargetTypes []string       `json:"supported_target_types"`
        SupportedFormats     []string       `json:"supported_formats"`
        MaxMessageSize       int            `json:"max_message_size"`
        SupportsScheduling   bool           `json:"supports_scheduling"`
        SupportsAttachments  bool           `json:"supports_attachments"`
        SupportsMentions     bool           `json:"supports_mentions"`
        SupportsRichContent  bool           `json:"supports_rich_content"`
        RateLimits           *RateLimitInfo `json:"rate_limits,omitempty"`
        RequiredSettings     []string       `json:"required_settings"`
}

// RateLimitInfo describes platform rate limiting information
type RateLimitInfo struct {
        RequestsPerSecond int           `json:"requests_per_second"`
        RequestsPerMinute int           `json:"requests_per_minute"`
        RequestsPerHour   int           `json:"requests_per_hour"`
        BurstSize         int           `json:"burst_size"`
        WindowSize        time.Duration `json:"window_size"`
}

// SenderFactory creates platform senders based on configuration
type SenderFactory interface {
        // CreateSender creates a new sender for the specified platform
        CreateSender(platform string, config map[string]interface{}) (Sender, error)

        // GetSupportedPlatforms returns a list of platforms this factory can create
        GetSupportedPlatforms() []string

        // ValidateConfig validates configuration for a platform
        ValidateConfig(platform string, config map[string]interface{}) error
}

// Manager manages multiple platform senders
type Manager interface {
        // RegisterSender registers a sender with the manager
        RegisterSender(sender Sender) error

        // GetSender retrieves a sender by platform name
        GetSender(platform string) (Sender, bool)

        // ListSenders returns all registered sender names
        ListSenders() []string

        // SendToAll sends a message to all targets across all relevant platforms
        SendToAll(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error)

        // HealthCheck checks the health of all registered senders
        HealthCheck(ctx context.Context) map[string]error

        // Close shuts down all senders
        Close() error
}

// MessageConverter converts between different message formats (placeholder)
type MessageConverter interface {
        // Placeholder - actual implementation depends on specific use case
        Convert(input interface{}) (interface{}, error)
        // ToInternal converts a message to internal format
        ToInternal(message interface{}, platform string) (*InternalMessage, error)
}

// Validator validates messages and targets
type Validator interface {
        // ValidateMessage validates a message for general requirements
        ValidateMessage(msg *InternalMessage) error

        // ValidateTarget validates a target format
        ValidateTarget(target InternalTarget) error

        // ValidateMessageForPlatform validates a message for a specific platform
        ValidateMessageForPlatform(msg *InternalMessage, platform string, capabilities PlatformCapabilities) error
}

// TargetResolver resolves target routing and platform assignment (placeholder)
type TargetResolver interface {
        // Placeholder - actual implementation depends on specific use case
        Resolve(input interface{}) (interface{}, error)
        // ResolveTargets determines which platform should handle each target
        ResolveTargets(targets interface{}) map[string][]InternalTarget
}

// HealthStatus represents the health status of a platform
type HealthStatus struct {
        Platform  string            `json:"platform"`
        Healthy   bool              `json:"healthy"`
        LastCheck time.Time         `json:"last_check"`
        Error     string            `json:"error,omitempty"`
        Metadata  map[string]string `json:"metadata,omitempty"`
}

// Error types for platform operations

// PlatformError represents a platform-specific error
type PlatformError struct {
        Platform string
        Code     string
        Message  string
        Cause    error
}

func (e *PlatformError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e *PlatformError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Common error codes
const (
        ErrorCodeInvalidConfig      = "INVALID_CONFIG"
        ErrorCodeUnsupportedTarget  = "UNSUPPORTED_TARGET"
        ErrorCodeUnsupportedFormat  = "UNSUPPORTED_FORMAT"
        ErrorCodeMessageTooLarge    = "MESSAGE_TOO_LARGE"
        ErrorCodeRateLimited        = "RATE_LIMITED"
        ErrorCodePlatformDown       = "PLATFORM_DOWN"
        ErrorCodeInvalidCredentials = "INVALID_CREDENTIALS"
        ErrorCodeNetworkError       = "NETWORK_ERROR"
        ErrorCodeTimeout            = "TIMEOUT"
)

// Utility functions

// NewInternalMessage creates a new internal message
func NewInternalMessage(id, title, body string) *InternalMessage <span class="cov8" title="1">{
        return &amp;InternalMessage{
                ID:           id,
                Title:        title,
                Body:         body,
                Format:       "text",
                Priority:     2, // Normal priority
                Metadata:     make(map[string]interface{}),
                Variables:    make(map[string]interface{}),
                PlatformData: make(map[string]interface{}),
        }
}</span>

// NewInternalTarget creates a new internal target
func NewInternalTarget(targetType, value, platform string) InternalTarget <span class="cov8" title="1">{
        return InternalTarget{
                Type:     targetType,
                Value:    value,
                Platform: platform,
        }
}</span>

// NewSendResult creates a new send result
func NewSendResult(target InternalTarget, success bool) *SendResult <span class="cov8" title="1">{
        return &amp;SendResult{
                Target:   target,
                Success:  success,
                SentAt:   time.Now(),
                Metadata: make(map[string]string),
        }
}</span>

// SetDuration sets the duration for the send result
func (r *SendResult) SetDuration(duration time.Duration) <span class="cov8" title="1">{
        r.Duration = duration
}</span>

// NewPlatformCapabilities creates a new platform capabilities structure
func NewPlatformCapabilities(name string) PlatformCapabilities <span class="cov8" title="1">{
        return PlatformCapabilities{
                Name:                 name,
                SupportedTargetTypes: make([]string, 0),
                SupportedFormats:     make([]string, 0),
                RequiredSettings:     make([]string, 0),
        }
}</span>

// NewPlatformError creates a new platform error
func NewPlatformError(platform, code, message string, cause error) *PlatformError <span class="cov8" title="1">{
        return &amp;PlatformError{
                Platform: platform,
                Code:     code,
                Message:  message,
                Cause:    cause,
        }
}</span>

// IsRetryableError checks if an error is retryable
func IsRetryableError(err error) bool <span class="cov8" title="1">{
        if platformErr, ok := err.(*PlatformError); ok </span><span class="cov8" title="1">{
                return platformErr.Code == ErrorCodeNetworkError ||
                        platformErr.Code == ErrorCodeTimeout ||
                        platformErr.Code == ErrorCodeRateLimited ||
                        platformErr.Code == ErrorCodePlatformDown
        }</span>
        <span class="cov8" title="1">return false</span>
}

// GetErrorCode extracts the error code from a platform error
func GetErrorCode(err error) string <span class="cov8" title="1">{
        if platformErr, ok := err.(*PlatformError); ok </span><span class="cov8" title="1">{
                return platformErr.Code
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package platform

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// manager implements the Manager interface for managing platform senders
type manager struct {
        senders   map[string]Sender
        mutex     sync.RWMutex
        factory   SenderFactory
        resolver  TargetResolver
        converter MessageConverter
        validator Validator
}

// NewManager creates a new platform manager
func NewManager(factory SenderFactory, resolver TargetResolver, converter MessageConverter, validator Validator) Manager <span class="cov8" title="1">{
        return &amp;manager{
                senders:   make(map[string]Sender),
                factory:   factory,
                resolver:  resolver,
                converter: converter,
                validator: validator,
        }
}</span>

// RegisterSender registers a sender with the manager
func (m *manager) RegisterSender(sender Sender) error <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        name := sender.Name()
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("sender name cannot be empty")
        }</span>

        <span class="cov8" title="1">if _, exists := m.senders[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("sender %s already registered", name)
        }</span>

        <span class="cov8" title="1">m.senders[name] = sender
        return nil</span>
}

// GetSender retrieves a sender by platform name
func (m *manager) GetSender(platform string) (Sender, bool) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        sender, exists := m.senders[platform]
        return sender, exists
}</span>

// ListSenders returns all registered sender names
func (m *manager) ListSenders() []string <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        names := make([]string, 0, len(m.senders))
        for name := range m.senders </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// SendToAll sends a message to all targets across all relevant platforms
func (m *manager) SendToAll(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error) <span class="cov8" title="1">{
        // Group targets by platform
        platformTargets := make(map[string][]InternalTarget)
        for _, target := range targets </span><span class="cov8" title="1">{
                platform := target.Platform
                platformTargets[platform] = append(platformTargets[platform], target)
        }</span>

        // Send to each platform in parallel
        <span class="cov8" title="1">type platformResult struct {
                platform string
                results  []*SendResult
                err      error
        }

        resultChan := make(chan platformResult, len(platformTargets))
        var wg sync.WaitGroup

        for platform, platformTargetList := range platformTargets </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(platform string, targets []InternalTarget) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        sender, exists := m.GetSender(platform)
                        if !exists </span><span class="cov8" title="1">{
                                // Create a failed result for each target
                                failedResults := make([]*SendResult, len(targets))
                                for i, target := range targets </span><span class="cov8" title="1">{
                                        result := NewSendResult(target, false)
                                        result.Error = fmt.Sprintf("platform %s not found", platform)
                                        failedResults[i] = result
                                }</span>
                                <span class="cov8" title="1">resultChan &lt;- platformResult{platform: platform, results: failedResults}
                                return</span>
                        }

                        // Send through platform
                        <span class="cov8" title="1">results, err := sender.Send(ctx, msg, targets)
                        resultChan &lt;- platformResult{platform: platform, results: results, err: err}</span>
                }(platform, platformTargetList)
        }

        // Wait for all platforms to complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        // Collect results
        <span class="cov8" title="1">var allResults []*SendResult
        var lastError error

        for result := range resultChan </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov8" title="1">{
                        lastError = result.err
                        // Create failed results if platform send failed completely
                        if result.results == nil </span><span class="cov8" title="1">{
                                platformTargetList := platformTargets[result.platform]
                                failedResults := make([]*SendResult, len(platformTargetList))
                                for i, target := range platformTargetList </span><span class="cov8" title="1">{
                                        sendResult := NewSendResult(target, false)
                                        sendResult.Error = result.err.Error()
                                        failedResults[i] = sendResult
                                }</span>
                                <span class="cov8" title="1">allResults = append(allResults, failedResults...)</span>
                        }
                } else<span class="cov8" title="1"> {
                        allResults = append(allResults, result.results...)
                }</span>
        }

        <span class="cov8" title="1">return allResults, lastError</span>
}

// HealthCheck checks the health of all registered senders
func (m *manager) HealthCheck(ctx context.Context) map[string]error <span class="cov8" title="1">{
        m.mutex.RLock()
        senders := make(map[string]Sender)
        for name, sender := range m.senders </span><span class="cov8" title="1">{
                senders[name] = sender
        }</span>
        <span class="cov8" title="1">m.mutex.RUnlock()

        health := make(map[string]error)
        var wg sync.WaitGroup
        var mutex sync.Mutex

        for name, sender := range senders </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(name string, sender Sender) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        err := sender.IsHealthy(ctx)
                        mutex.Lock()
                        health[name] = err
                        mutex.Unlock()
                }</span>(name, sender)
        }

        <span class="cov8" title="1">wg.Wait()
        return health</span>
}

// Close shuts down all senders
func (m *manager) Close() error <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        var lastError error
        for name, sender := range m.senders </span><span class="cov8" title="1">{
                if err := sender.Close(); err != nil </span><span class="cov8" title="1">{
                        lastError = fmt.Errorf("failed to close sender %s: %w", name, err)
                }</span>
        }

        // Clear the senders map
        <span class="cov8" title="1">m.senders = make(map[string]Sender)

        return lastError</span>
}

// defaultSenderFactory implements SenderFactory with support for common platforms
type defaultSenderFactory struct{}

// NewDefaultSenderFactory creates a default sender factory
func NewDefaultSenderFactory() SenderFactory <span class="cov8" title="1">{
        return &amp;defaultSenderFactory{}
}</span>

// CreateSender creates a new sender for the specified platform
func (f *defaultSenderFactory) CreateSender(platformName string, config map[string]interface{}) (Sender, error) <span class="cov0" title="0">{
        // Import platform packages to create actual senders
        switch platformName </span>{
        case "email":<span class="cov0" title="0">
                // Create email sender using the specific implementation
                return createEmailSender(config)</span>
        case "feishu":<span class="cov0" title="0">
                // Create feishu sender using the specific implementation
                return createFeishuSender(config)</span>
        case "sms":<span class="cov0" title="0">
                // Create SMS sender using the specific implementation
                return createSMSSender(config)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported platform: %s", platformName)</span>
        }
}

// GetSupportedPlatforms returns a list of platforms this factory can create
func (f *defaultSenderFactory) GetSupportedPlatforms() []string <span class="cov8" title="1">{
        return []string{"email", "feishu", "sms"}
}</span>

// ValidateConfig validates configuration for a platform
func (f *defaultSenderFactory) ValidateConfig(platform string, config map[string]interface{}) error <span class="cov8" title="1">{
        switch platform </span>{
        case "email":<span class="cov8" title="1">
                required := []string{"smtp_host", "smtp_port", "smtp_username", "smtp_password", "smtp_from"}
                return validateRequiredFields(config, required)</span>
        case "feishu":<span class="cov8" title="1">
                required := []string{"webhook_url"}
                return validateRequiredFields(config, required)</span>
        case "sms":<span class="cov8" title="1">
                required := []string{"provider", "api_key"}
                return validateRequiredFields(config, required)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported platform: %s", platform)</span>
        }
}

// Factory methods have been removed - platform senders are created directly

// defaultMessageConverter implements MessageConverter
type defaultMessageConverter struct{}

// NewDefaultMessageConverter creates a default message converter
func NewDefaultMessageConverter() MessageConverter <span class="cov8" title="1">{
        return &amp;defaultMessageConverter{}
}</span>

// Convert performs placeholder conversion
func (c *defaultMessageConverter) Convert(input interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Placeholder implementation - actual conversion logic would go here
        return input, nil
}</span>

// ToInternal converts a message to internal format
func (c *defaultMessageConverter) ToInternal(message interface{}, platform string) (*InternalMessage, error) <span class="cov8" title="1">{
        // We need to import the Message type, but to avoid import cycles,
        // we'll use interface{} and type assertion
        msg, ok := message.(*InternalMessage)
        if ok </span><span class="cov0" title="0">{
                // Already converted
                return msg, nil
        }</span>

        // For now, create a basic conversion
        // In a real implementation, this would convert from public Message to InternalMessage
        <span class="cov8" title="1">return &amp;InternalMessage{
                ID:           generateMessageID(),
                Title:        "Converted Message",
                Body:         "Message body",
                Format:       "text",
                Priority:     2,
                Metadata:     make(map[string]interface{}),
                Variables:    make(map[string]interface{}),
                PlatformData: make(map[string]interface{}),
        }, nil</span>
}

// generateMessageID generates a unique message ID
func generateMessageID() string <span class="cov8" title="1">{
        return fmt.Sprintf("msg_%d", time.Now().UnixNano())
}</span>

// defaultValidator implements Validator
type defaultValidator struct{}

// NewDefaultValidator creates a default validator
func NewDefaultValidator() Validator <span class="cov8" title="1">{
        return &amp;defaultValidator{}
}</span>

// ValidateMessage validates a message for general requirements
func (v *defaultValidator) ValidateMessage(msg *InternalMessage) error <span class="cov8" title="1">{
        if msg.Title == "" &amp;&amp; msg.Body == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("message must have either title or body")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTarget validates a target format
func (v *defaultValidator) ValidateTarget(target InternalTarget) error <span class="cov8" title="1">{
        if target.Value == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("target value cannot be empty")
        }</span>
        <span class="cov8" title="1">if target.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("target type cannot be empty")
        }</span>
        <span class="cov8" title="1">if target.Platform == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("target platform cannot be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateMessageForPlatform validates a message for a specific platform
func (v *defaultValidator) ValidateMessageForPlatform(msg *InternalMessage, platform string, capabilities PlatformCapabilities) error <span class="cov0" title="0">{
        // Check message size
        if capabilities.MaxMessageSize &gt; 0 </span><span class="cov0" title="0">{
                messageSize := len(msg.Title) + len(msg.Body)
                if messageSize &gt; capabilities.MaxMessageSize </span><span class="cov0" title="0">{
                        return fmt.Errorf("message size (%d bytes) exceeds platform limit (%d bytes)", messageSize, capabilities.MaxMessageSize)
                }</span>
        }

        // Check format support
        <span class="cov0" title="0">if len(capabilities.SupportedFormats) &gt; 0 </span><span class="cov0" title="0">{
                supported := false
                for _, format := range capabilities.SupportedFormats </span><span class="cov0" title="0">{
                        if format == msg.Format </span><span class="cov0" title="0">{
                                supported = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !supported </span><span class="cov0" title="0">{
                        return fmt.Errorf("format %s not supported by platform %s", msg.Format, platform)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// defaultTargetResolver implements TargetResolver
type defaultTargetResolver struct{}

// NewDefaultTargetResolver creates a default target resolver
func NewDefaultTargetResolver() TargetResolver <span class="cov8" title="1">{
        return &amp;defaultTargetResolver{}
}</span>

// Resolve performs placeholder resolution
func (r *defaultTargetResolver) Resolve(input interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Placeholder implementation - actual resolution logic would go here
        return input, nil
}</span>

// ResolveTargets determines which platform should handle each target
func (r *defaultTargetResolver) ResolveTargets(targets interface{}) map[string][]InternalTarget <span class="cov8" title="1">{
        // For now, create a basic implementation that handles common target types
        result := make(map[string][]InternalTarget)

        // Assuming targets is a slice, try to convert it
        if targetSlice, ok := targets.([]interface{}); ok </span><span class="cov8" title="1">{
                for _, target := range targetSlice </span><span class="cov8" title="1">{
                        if targetMap, ok := target.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                targetType, _ := targetMap["type"].(string)
                                targetValue, _ := targetMap["value"].(string)
                                platform, _ := targetMap["platform"].(string)

                                if platform == "" </span><span class="cov8" title="1">{
                                        // Auto-detect platform based on target type
                                        switch targetType </span>{
                                        case "email":<span class="cov0" title="0">
                                                platform = "email"</span>
                                        case "phone":<span class="cov8" title="1">
                                                platform = "sms"</span>
                                        case "user", "group", "webhook":<span class="cov0" title="0">
                                                platform = "feishu"</span>
                                        }
                                }

                                <span class="cov8" title="1">if platform != "" </span><span class="cov8" title="1">{
                                        internalTarget := InternalTarget{
                                                Type:     targetType,
                                                Value:    targetValue,
                                                Platform: platform,
                                        }
                                        result[platform] = append(result[platform], internalTarget)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateTargetForPlatform checks if a target is valid for a platform
func (r *defaultTargetResolver) ValidateTargetForPlatform(target InternalTarget, platform string) error <span class="cov0" title="0">{
        switch platform </span>{
        case "email":<span class="cov0" title="0">
                if target.Type != "email" </span><span class="cov0" title="0">{
                        return fmt.Errorf("email platform only supports email targets")
                }</span>
        case "sms":<span class="cov0" title="0">
                if target.Type != "phone" </span><span class="cov0" title="0">{
                        return fmt.Errorf("sms platform only supports phone targets")
                }</span>
        case "feishu":<span class="cov0" title="0">
                if target.Type != "user" &amp;&amp; target.Type != "group" &amp;&amp; target.Type != "webhook" </span><span class="cov0" title="0">{
                        return fmt.Errorf("feishu platform only supports user, group, and webhook targets")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Utility functions

// validateRequiredFields validates that required fields are present in config
func validateRequiredFields(config map[string]interface{}, required []string) error <span class="cov8" title="1">{
        for _, field := range required </span><span class="cov8" title="1">{
                if _, exists := config[field]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("required field %s is missing", field)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Platform-specific sender creation functions

// createEmailSender creates an email sender with the given configuration
func createEmailSender(config map[string]interface{}) (Sender, error) <span class="cov0" title="0">{
        // Import the actual email sender implementation
        // We need to avoid import cycles, so we'll use internal imports
        // For now, create a basic implementation

        // Extract required configuration
        host, _ := config["smtp_host"].(string)
        port, _ := config["smtp_port"].(int)
        username, _ := config["smtp_username"].(string)
        password, _ := config["smtp_password"].(string)
        from, _ := config["smtp_from"].(string)
        useTLS, _ := config["smtp_tls"].(bool)

        if host == "" || username == "" || password == "" || from == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required email configuration fields")
        }</span>

        // Return a basic email sender implementation
        <span class="cov0" title="0">return &amp;basicEmailSender{
                host:     host,
                port:     port,
                username: username,
                password: password,
                from:     from,
                useTLS:   useTLS,
        }, nil</span>
}

// createFeishuSender creates a feishu sender with the given configuration
func createFeishuSender(config map[string]interface{}) (Sender, error) <span class="cov0" title="0">{
        webhookURL, _ := config["webhook_url"].(string)
        secret, _ := config["secret"].(string)

        if webhookURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required feishu configuration: webhook_url")
        }</span>

        <span class="cov0" title="0">return &amp;basicFeishuSender{
                webhookURL: webhookURL,
                secret:     secret,
        }, nil</span>
}

// createSMSSender creates an SMS sender with the given configuration
func createSMSSender(config map[string]interface{}) (Sender, error) <span class="cov0" title="0">{
        provider, _ := config["provider"].(string)
        apiKey, _ := config["api_key"].(string)

        if provider == "" || apiKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required SMS configuration fields")
        }</span>

        <span class="cov0" title="0">return &amp;basicSMSSender{
                provider: provider,
                apiKey:   apiKey,
        }, nil</span>
}

// Basic sender implementations (placeholder implementations for now)

type basicEmailSender struct {
        host     string
        port     int
        username string
        password string
        from     string
        useTLS   bool
}

func (s *basicEmailSender) Name() string <span class="cov0" title="0">{ return "email" }</span>

func (s *basicEmailSender) Send(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error) <span class="cov0" title="0">{
        results := make([]*SendResult, len(targets))
        for i, target := range targets </span><span class="cov0" title="0">{
                result := NewSendResult(target, true)
                result.MessageID = fmt.Sprintf("email_%s_%d", msg.ID, i)
                // For demo purposes, mark as successful
                results[i] = result
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (s *basicEmailSender) ValidateTarget(target InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "email" </span><span class="cov0" title="0">{
                return fmt.Errorf("email sender only supports email targets")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *basicEmailSender) GetCapabilities() PlatformCapabilities <span class="cov0" title="0">{
        return PlatformCapabilities{
                Name:                 "email",
                SupportedTargetTypes: []string{"email"},
                SupportedFormats:     []string{"text", "html"},
                MaxMessageSize:       1024 * 1024, // 1MB
                SupportsScheduling:   true,
                SupportsAttachments:  true,
                RequiredSettings:     []string{"smtp_host", "smtp_port", "smtp_username", "smtp_password", "smtp_from"},
        }
}</span>

func (s *basicEmailSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{ return nil }</span>
func (s *basicEmailSender) Close() error                        <span class="cov0" title="0">{ return nil }</span>

type basicFeishuSender struct {
        webhookURL string
        secret     string
}

func (s *basicFeishuSender) Name() string <span class="cov0" title="0">{ return "feishu" }</span>

func (s *basicFeishuSender) Send(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error) <span class="cov0" title="0">{
        results := make([]*SendResult, len(targets))
        for i, target := range targets </span><span class="cov0" title="0">{
                result := NewSendResult(target, true)
                result.MessageID = fmt.Sprintf("feishu_%s_%d", msg.ID, i)
                // For demo purposes, mark as successful
                results[i] = result
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (s *basicFeishuSender) ValidateTarget(target InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "user" &amp;&amp; target.Type != "group" &amp;&amp; target.Type != "webhook" </span><span class="cov0" title="0">{
                return fmt.Errorf("feishu sender supports user, group, and webhook targets")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *basicFeishuSender) GetCapabilities() PlatformCapabilities <span class="cov0" title="0">{
        return PlatformCapabilities{
                Name:                 "feishu",
                SupportedTargetTypes: []string{"user", "group", "webhook"},
                SupportedFormats:     []string{"text", "markdown"},
                MaxMessageSize:       30000, // 30KB
                SupportsScheduling:   false,
                SupportsRichContent:  true,
                SupportsMentions:     true,
                RequiredSettings:     []string{"webhook_url"},
        }
}</span>

func (s *basicFeishuSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{ return nil }</span>
func (s *basicFeishuSender) Close() error                        <span class="cov0" title="0">{ return nil }</span>

type basicSMSSender struct {
        provider string
        apiKey   string
}

func (s *basicSMSSender) Name() string <span class="cov0" title="0">{ return "sms" }</span>

func (s *basicSMSSender) Send(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error) <span class="cov0" title="0">{
        results := make([]*SendResult, len(targets))
        for i, target := range targets </span><span class="cov0" title="0">{
                result := NewSendResult(target, true)
                result.MessageID = fmt.Sprintf("sms_%s_%d", msg.ID, i)
                // For demo purposes, mark as successful
                results[i] = result
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (s *basicSMSSender) ValidateTarget(target InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "phone" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMS sender only supports phone targets")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *basicSMSSender) GetCapabilities() PlatformCapabilities <span class="cov0" title="0">{
        return PlatformCapabilities{
                Name:                 "sms",
                SupportedTargetTypes: []string{"phone"},
                SupportedFormats:     []string{"text"},
                MaxMessageSize:       160, // Standard SMS limit
                SupportsScheduling:   true,
                RequiredSettings:     []string{"provider", "api_key"},
        }
}</span>

func (s *basicSMSSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{ return nil }</span>
func (s *basicSMSSender) Close() error                        <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package sms implements the SMS Sender for SMS notifications through various providers
// This integrates all SMS-specific logic including provider integration, message formatting, and phone number validation
package sms

import (
        "context"
        "fmt"
        "net/http"
        "regexp"
        "strings"
        "time"

        "github.com/kart-io/notifyhub/internal/platform"
)

// SMSSender implements the platform.Sender interface for SMS notifications
type SMSSender struct {
        name     string
        config   SMSConfig
        provider SMSProvider
        client   *http.Client
}

// SMSConfig holds SMS configuration
type SMSConfig struct {
        Provider  string        `json:"provider"` // "twilio", "aliyun", "tencent", "aws_sns"
        APIKey    string        `json:"api_key"`
        APISecret string        `json:"api_secret,omitempty"`
        Region    string        `json:"region,omitempty"`
        From      string        `json:"from"` // Sender phone number or ID
        Timeout   time.Duration `json:"timeout"`
        Template  string        `json:"template,omitempty"`  // SMS template ID
        SignName  string        `json:"sign_name,omitempty"` // SMS signature name
}

// SMSProvider interface for different SMS service providers
type SMSProvider interface {
        SendSMS(ctx context.Context, to, message string, config SMSConfig) (*SMSResponse, error)
        ValidatePhoneNumber(phone string) error
        GetProviderName() string
}

// SMSResponse represents SMS API response
type SMSResponse struct {
        MessageID   string `json:"message_id"`
        Status      string `json:"status"`
        StatusCode  int    `json:"status_code"`
        Description string `json:"description,omitempty"`
        Cost        string `json:"cost,omitempty"`
}

// NewSMSSender creates a new SMS sender
func NewSMSSender(config map[string]interface{}) (platform.Sender, error) <span class="cov0" title="0">{
        smsConfig, err := parseSMSConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sms configuration: %w", err)
        }</span>

        // Create provider based on configuration
        <span class="cov0" title="0">provider, err := createSMSProvider(smsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SMS provider: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SMSSender{
                name:     "sms",
                config:   smsConfig,
                provider: provider,
                client: &amp;http.Client{
                        Timeout: smsConfig.Timeout,
                },
        }, nil</span>
}

// Name returns the platform name
func (s *SMSSender) Name() string <span class="cov0" title="0">{
        return s.name
}</span>

// Send sends an SMS message to the specified targets
func (s *SMSSender) Send(ctx context.Context, msg *platform.InternalMessage, targets []platform.InternalTarget) ([]*platform.SendResult, error) <span class="cov0" title="0">{
        results := make([]*platform.SendResult, len(targets))

        for i, target := range targets </span><span class="cov0" title="0">{
                startTime := time.Now()
                result := platform.NewSendResult(target, false)

                // Validate target
                if err := s.ValidateTarget(target); err != nil </span><span class="cov0" title="0">{
                        result.Error = err.Error()
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Build SMS content
                <span class="cov0" title="0">smsContent, err := s.buildSMSContent(msg, target)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to build sms content: %v", err)
                        result.SetDuration(time.Since(startTime))
                        results[i] = result
                        continue</span>
                }

                // Send SMS
                <span class="cov0" title="0">response, err := s.provider.SendSMS(ctx, target.Value, smsContent, s.config)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("failed to send sms: %v", err)
                }</span> else<span class="cov0" title="0"> if response.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("sms provider error: %s (code: %d)", response.Description, response.StatusCode)
                }</span> else<span class="cov0" title="0"> {
                        result.Success = true
                        result.MessageID = response.MessageID
                        result.StatusCode = response.StatusCode
                        result.Response = response.Description
                }</span>

                <span class="cov0" title="0">result.SetDuration(time.Since(startTime))
                results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// ValidateTarget validates an SMS target
func (s *SMSSender) ValidateTarget(target platform.InternalTarget) error <span class="cov0" title="0">{
        if target.Type != "phone" </span><span class="cov0" title="0">{
                return fmt.Errorf("sms sender only supports phone targets, got %s", target.Type)
        }</span>

        <span class="cov0" title="0">if target.Value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("phone number cannot be empty")
        }</span>

        // Use provider-specific validation
        <span class="cov0" title="0">return s.provider.ValidatePhoneNumber(target.Value)</span>
}

// GetCapabilities returns the SMS platform capabilities
func (s *SMSSender) GetCapabilities() platform.PlatformCapabilities <span class="cov0" title="0">{
        return platform.PlatformCapabilities{
                Name:                 "sms",
                SupportedTargetTypes: []string{"phone"},
                SupportedFormats:     []string{"text"},
                MaxMessageSize:       160, // Standard SMS length
                SupportsScheduling:   false,
                SupportsAttachments:  false,
                SupportsMentions:     false,
                SupportsRichContent:  false,
                RequiredSettings:     []string{"provider", "api_key", "from"},
                RateLimits: &amp;platform.RateLimitInfo{
                        RequestsPerSecond: 10,
                        RequestsPerMinute: 100,
                        BurstSize:         20,
                },
        }
}</span>

// IsHealthy checks if the SMS sender is healthy
func (s *SMSSender) IsHealthy(ctx context.Context) error <span class="cov0" title="0">{
        // For SMS, we can check if the provider is configured correctly
        // without actually sending a test message
        if s.provider == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sms provider not initialized")
        }</span>

        <span class="cov0" title="0">if s.config.APIKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sms api key not configured")
        }</span>

        // Test phone number validation with a known valid format
        <span class="cov0" title="0">testPhone := "+1234567890"
        if err := s.provider.ValidatePhoneNumber(testPhone); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sms provider validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close cleans up the SMS sender resources
func (s *SMSSender) Close() error <span class="cov0" title="0">{
        // SMS sender doesn't hold persistent connections
        return nil
}</span>

// buildSMSContent builds the SMS content from the internal message
func (s *SMSSender) buildSMSContent(msg *platform.InternalMessage, target platform.InternalTarget) (string, error) <span class="cov0" title="0">{
        var content string

        // Check if there's SMS template data
        if templateData, ok := msg.PlatformData["sms_template"]; ok </span><span class="cov0" title="0">{
                // Use template with variables
                if variables, hasVars := msg.PlatformData["sms_variables"].(map[string]interface{}); hasVars </span><span class="cov0" title="0">{
                        content = s.renderTemplate(templateData.(string), variables)
                }</span> else<span class="cov0" title="0"> {
                        content = templateData.(string)
                }</span>
        } else<span class="cov0" title="0"> {
                // Build content from title and body
                if msg.Title != "" &amp;&amp; msg.Body != "" </span><span class="cov0" title="0">{
                        content = fmt.Sprintf("%s: %s", msg.Title, msg.Body)
                }</span> else<span class="cov0" title="0"> if msg.Title != "" </span><span class="cov0" title="0">{
                        content = msg.Title
                }</span> else<span class="cov0" title="0"> {
                        content = msg.Body
                }</span>
        }

        // Add signature if configured
        <span class="cov0" title="0">if s.config.SignName != "" </span><span class="cov0" title="0">{
                content = fmt.Sprintf("【%s】%s", s.config.SignName, content)
        }</span>

        // Ensure content doesn't exceed SMS limits
        <span class="cov0" title="0">if len(content) &gt; 160 </span><span class="cov0" title="0">{
                // Truncate to fit SMS limit
                content = content[:157] + "..."
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// renderTemplate performs simple variable substitution
func (s *SMSSender) renderTemplate(template string, variables map[string]interface{}) string <span class="cov0" title="0">{
        result := template
        for key, value := range variables </span><span class="cov0" title="0">{
                placeholder := fmt.Sprintf("{{%s}}", key)
                result = strings.ReplaceAll(result, placeholder, fmt.Sprintf("%v", value))
        }</span>
        <span class="cov0" title="0">return result</span>
}

// parseSMSConfig parses SMS configuration from map
func parseSMSConfig(config map[string]interface{}) (SMSConfig, error) <span class="cov0" title="0">{
        smsConfig := SMSConfig{
                Timeout: 30 * time.Second, // Default timeout
        }

        // Required fields
        if provider, ok := config["provider"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.Provider = provider
        }</span> else<span class="cov0" title="0"> {
                return smsConfig, fmt.Errorf("provider is required")
        }</span>

        <span class="cov0" title="0">if apiKey, ok := config["api_key"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.APIKey = apiKey
        }</span> else<span class="cov0" title="0"> {
                return smsConfig, fmt.Errorf("api_key is required")
        }</span>

        <span class="cov0" title="0">if from, ok := config["from"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.From = from
        }</span> else<span class="cov0" title="0"> {
                return smsConfig, fmt.Errorf("from is required")
        }</span>

        // Optional fields
        <span class="cov0" title="0">if apiSecret, ok := config["api_secret"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.APISecret = apiSecret
        }</span>

        <span class="cov0" title="0">if region, ok := config["region"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.Region = region
        }</span>

        <span class="cov0" title="0">if template, ok := config["template"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.Template = template
        }</span>

        <span class="cov0" title="0">if signName, ok := config["sign_name"].(string); ok </span><span class="cov0" title="0">{
                smsConfig.SignName = signName
        }</span>

        <span class="cov0" title="0">if timeout, ok := config["timeout"].(time.Duration); ok </span><span class="cov0" title="0">{
                smsConfig.Timeout = timeout
        }</span>

        <span class="cov0" title="0">return smsConfig, nil</span>
}

// createSMSProvider creates the appropriate SMS provider based on configuration
func createSMSProvider(config SMSConfig) (SMSProvider, error) <span class="cov0" title="0">{
        switch strings.ToLower(config.Provider) </span>{
        case "twilio":<span class="cov0" title="0">
                return newTwilioProvider(), nil</span>
        case "aliyun", "alibaba":<span class="cov0" title="0">
                return newAliyunProvider(), nil</span>
        case "tencent":<span class="cov0" title="0">
                return newTencentProvider(), nil</span>
        case "aws_sns", "aws":<span class="cov0" title="0">
                return newAWSSNSProvider(), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported SMS provider: %s", config.Provider)</span>
        }
}

// Basic SMS provider implementations

// TwilioProvider implements Twilio SMS service
type TwilioProvider struct{}

func newTwilioProvider() *TwilioProvider <span class="cov0" title="0">{
        return &amp;TwilioProvider{}
}</span>

func (p *TwilioProvider) GetProviderName() string <span class="cov0" title="0">{
        return "twilio"
}</span>

func (p *TwilioProvider) ValidatePhoneNumber(phone string) error <span class="cov0" title="0">{
        // Twilio accepts E.164 format: +[country code][number]
        phoneRegex := regexp.MustCompile(`^\+[1-9]\d{1,14}$`)
        if !phoneRegex.MatchString(phone) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid phone number format for Twilio: %s (expected E.164 format like +1234567890)", phone)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *TwilioProvider) SendSMS(ctx context.Context, to, message string, config SMSConfig) (*SMSResponse, error) <span class="cov0" title="0">{
        // TODO: Implement actual Twilio API call
        // This is a placeholder implementation
        return &amp;SMSResponse{
                MessageID:   fmt.Sprintf("twilio_%d", time.Now().UnixNano()),
                Status:      "sent",
                StatusCode:  200,
                Description: "Message sent successfully",
        }, nil
}</span>

// AliyunProvider implements Alibaba Cloud SMS service
type AliyunProvider struct{}

func newAliyunProvider() *AliyunProvider <span class="cov0" title="0">{
        return &amp;AliyunProvider{}
}</span>

func (p *AliyunProvider) GetProviderName() string <span class="cov0" title="0">{
        return "aliyun"
}</span>

func (p *AliyunProvider) ValidatePhoneNumber(phone string) error <span class="cov0" title="0">{
        // Aliyun supports various formats, but prefer international format
        phoneRegex := regexp.MustCompile(`^(\+86)?1[3-9]\d{9}$`)
        if !phoneRegex.MatchString(phone) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid phone number format for Aliyun: %s", phone)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *AliyunProvider) SendSMS(ctx context.Context, to, message string, config SMSConfig) (*SMSResponse, error) <span class="cov0" title="0">{
        // TODO: Implement actual Aliyun SMS API call
        return &amp;SMSResponse{
                MessageID:   fmt.Sprintf("aliyun_%d", time.Now().UnixNano()),
                Status:      "sent",
                StatusCode:  200,
                Description: "Message sent successfully",
        }, nil
}</span>

// TencentProvider implements Tencent Cloud SMS service
type TencentProvider struct{}

func newTencentProvider() *TencentProvider <span class="cov0" title="0">{
        return &amp;TencentProvider{}
}</span>

func (p *TencentProvider) GetProviderName() string <span class="cov0" title="0">{
        return "tencent"
}</span>

func (p *TencentProvider) ValidatePhoneNumber(phone string) error <span class="cov0" title="0">{
        // Tencent SMS supports international format
        phoneRegex := regexp.MustCompile(`^\+[1-9]\d{1,14}$`)
        if !phoneRegex.MatchString(phone) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid phone number format for Tencent: %s", phone)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *TencentProvider) SendSMS(ctx context.Context, to, message string, config SMSConfig) (*SMSResponse, error) <span class="cov0" title="0">{
        // TODO: Implement actual Tencent SMS API call
        return &amp;SMSResponse{
                MessageID:   fmt.Sprintf("tencent_%d", time.Now().UnixNano()),
                Status:      "sent",
                StatusCode:  200,
                Description: "Message sent successfully",
        }, nil
}</span>

// AWSSNSProvider implements AWS SNS SMS service
type AWSSNSProvider struct{}

func newAWSSNSProvider() *AWSSNSProvider <span class="cov0" title="0">{
        return &amp;AWSSNSProvider{}
}</span>

func (p *AWSSNSProvider) GetProviderName() string <span class="cov0" title="0">{
        return "aws_sns"
}</span>

func (p *AWSSNSProvider) ValidatePhoneNumber(phone string) error <span class="cov0" title="0">{
        // AWS SNS requires E.164 format
        phoneRegex := regexp.MustCompile(`^\+[1-9]\d{1,14}$`)
        if !phoneRegex.MatchString(phone) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid phone number format for AWS SNS: %s (expected E.164 format)", phone)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *AWSSNSProvider) SendSMS(ctx context.Context, to, message string, config SMSConfig) (*SMSResponse, error) <span class="cov0" title="0">{
        // TODO: Implement actual AWS SNS API call
        return &amp;SMSResponse{
                MessageID:   fmt.Sprintf("aws_sns_%d", time.Now().UnixNano()),
                Status:      "sent",
                StatusCode:  200,
                Description: "Message sent successfully",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package platform

import (
        "context"
        "time"
)

// MockSender is a mock implementation of the Sender interface for testing
type MockSender struct {
        name         string
        sendError    error
        sendResults  []*SendResult
        validateErr  error
        capabilities PlatformCapabilities
        healthErr    error
        closeErr     error
}

// NewMockSender creates a new mock sender
func NewMockSender(name string) *MockSender <span class="cov8" title="1">{
        return &amp;MockSender{
                name: name,
                capabilities: PlatformCapabilities{
                        Name:                 name,
                        SupportedTargetTypes: []string{"test"},
                        SupportedFormats:     []string{"text"},
                        MaxMessageSize:       1000,
                        RequiredSettings:     []string{},
                },
        }
}</span>

// Name returns the mock sender name
func (m *MockSender) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

// Send mocks sending a message
func (m *MockSender) Send(ctx context.Context, msg *InternalMessage, targets []InternalTarget) ([]*SendResult, error) <span class="cov8" title="1">{
        if m.sendError != nil </span><span class="cov8" title="1">{
                return nil, m.sendError
        }</span>

        <span class="cov8" title="1">if m.sendResults != nil </span><span class="cov0" title="0">{
                return m.sendResults, nil
        }</span>

        // Default: create successful results
        <span class="cov8" title="1">results := make([]*SendResult, len(targets))
        for i, target := range targets </span><span class="cov8" title="1">{
                results[i] = &amp;SendResult{
                        Target:    target,
                        Success:   true,
                        MessageID: "mock_" + msg.ID + "_" + target.Value,
                        SentAt:    time.Now(),
                        Duration:  time.Millisecond * 100,
                        Metadata:  make(map[string]string),
                }
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

// ValidateTarget mocks target validation
func (m *MockSender) ValidateTarget(target InternalTarget) error <span class="cov0" title="0">{
        return m.validateErr
}</span>

// GetCapabilities returns mock capabilities
func (m *MockSender) GetCapabilities() PlatformCapabilities <span class="cov0" title="0">{
        return m.capabilities
}</span>

// IsHealthy mocks health check
func (m *MockSender) IsHealthy(ctx context.Context) error <span class="cov8" title="1">{
        return m.healthErr
}</span>

// Close mocks closing the sender
func (m *MockSender) Close() error <span class="cov8" title="1">{
        return m.closeErr
}</span>

// SetSendError sets an error to be returned by Send
func (m *MockSender) SetSendError(err error) <span class="cov8" title="1">{
        m.sendError = err
}</span>

// SetSendResults sets specific results to be returned by Send
func (m *MockSender) SetSendResults(results []*SendResult) <span class="cov0" title="0">{
        m.sendResults = results
}</span>

// SetValidateError sets an error to be returned by ValidateTarget
func (m *MockSender) SetValidateError(err error) <span class="cov0" title="0">{
        m.validateErr = err
}</span>

// SetHealthError sets an error to be returned by IsHealthy
func (m *MockSender) SetHealthError(err error) <span class="cov8" title="1">{
        m.healthErr = err
}</span>

// SetCloseError sets an error to be returned by Close
func (m *MockSender) SetCloseError(err error) <span class="cov8" title="1">{
        m.closeErr = err
}</span>

// MockSenderFactory is a mock implementation of SenderFactory
type MockSenderFactory struct {
        senders map[string]Sender
        errors  map[string]error
}

// NewMockSenderFactory creates a new mock sender factory
func NewMockSenderFactory() *MockSenderFactory <span class="cov8" title="1">{
        return &amp;MockSenderFactory{
                senders: make(map[string]Sender),
                errors:  make(map[string]error),
        }
}</span>

// CreateSender creates a mock sender or returns an error
func (f *MockSenderFactory) CreateSender(platform string, config map[string]interface{}) (Sender, error) <span class="cov0" title="0">{
        if err, exists := f.errors[platform]; exists </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if sender, exists := f.senders[platform]; exists </span><span class="cov0" title="0">{
                return sender, nil
        }</span>
        <span class="cov0" title="0">return NewMockSender(platform), nil</span>
}

// GetSupportedPlatforms returns mock supported platforms
func (f *MockSenderFactory) GetSupportedPlatforms() []string <span class="cov0" title="0">{
        var platforms []string
        for platform := range f.senders </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>
        <span class="cov0" title="0">return platforms</span>
}

// ValidateConfig always returns nil for mocking
func (f *MockSenderFactory) ValidateConfig(platform string, config map[string]interface{}) error <span class="cov0" title="0">{
        if err, exists := f.errors[platform]; exists </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddSender adds a mock sender for a platform
func (f *MockSenderFactory) AddSender(platform string, sender Sender) <span class="cov0" title="0">{
        f.senders[platform] = sender
}</span>

// SetError sets an error for a platform
func (f *MockSenderFactory) SetError(platform string, err error) <span class="cov0" title="0">{
        f.errors[platform] = err
}</pre>
		
		<pre class="file" id="file7" style="display: none">// Package notifyhub provides configuration utilities and defaults for the NotifyHub system
package notifyhub

import (
        "time"
)

// DefaultConfig creates a default configuration suitable for most use cases
func DefaultConfig() []HubOption <span class="cov0" title="0">{
        return []HubOption{
                WithTimeout(30 * time.Second),
                WithRetry(3, time.Second, 2.0),
                WithMemoryQueue(1000, 4),
                WithMetrics(false),
                WithTracing(false),
                WithHealthCheck(30*time.Second, 5*time.Second, 3),
        }
}</span>

// TestConfig creates a configuration optimized for testing
func TestConfig() []HubOption <span class="cov0" title="0">{
        return []HubOption{
                WithTimeout(5 * time.Second),
                WithRetry(1, 100*time.Millisecond, 1.0),
                WithMemoryQueue(10, 1),
                WithMetrics(false),
                WithTracing(false),
                WithNoHealthCheck(),
        }
}</span>

// ProductionConfig creates a configuration optimized for production use
func ProductionConfig() []HubOption <span class="cov0" title="0">{
        return []HubOption{
                WithTimeout(30 * time.Second),
                WithRetry(5, time.Second, 2.0),
                WithRateLimit(1000, time.Minute),
                WithMetrics(true),
                WithTracing(true),
                WithHealthCheck(15*time.Second, 10*time.Second, 3),
                WithSecurity(true, nil, nil),
        }
}</span>

// QuickStart provides a quick way to get started with common platforms
func QuickStart() QuickStartConfig <span class="cov0" title="0">{
        return QuickStartConfig{}
}</span>

// QuickStartConfig provides a fluent interface for quick configuration
type QuickStartConfig struct {
        options []HubOption
}

// WithFeishuWebhook adds Feishu webhook configuration
func (c QuickStartConfig) WithFeishuWebhook(webhookURL, secret string) QuickStartConfig <span class="cov0" title="0">{
        c.options = append(c.options, WithFeishu(webhookURL, secret))
        return c
}</span>

// WithEmailSMTP adds email SMTP configuration
func (c QuickStartConfig) WithEmailSMTP(host string, port int, username, password, from string) QuickStartConfig <span class="cov0" title="0">{
        c.options = append(c.options, WithEmail(host, port, username, password, from))
        return c
}</span>

// WithSMSProvider adds SMS provider configuration
func (c QuickStartConfig) WithSMSProvider(provider, apiKey, apiSecret string) QuickStartConfig <span class="cov0" title="0">{
        c.options = append(c.options, WithSMS(provider, apiKey, apiSecret))
        return c
}</span>

// Build creates the hub with the configured options
func (c QuickStartConfig) Build() (Hub, error) <span class="cov0" title="0">{
        opts := append(DefaultConfig(), c.options...)
        return NewHub(opts...)
}</span>

// Environment variable keys for configuration
const (
        EnvFeishuWebhookURL = "NOTIFYHUB_FEISHU_WEBHOOK_URL"
        EnvFeishuSecret     = "NOTIFYHUB_FEISHU_SECRET"

        EnvEmailHost     = "NOTIFYHUB_EMAIL_HOST"
        EnvEmailPort     = "NOTIFYHUB_EMAIL_PORT"
        EnvEmailUsername = "NOTIFYHUB_EMAIL_USERNAME"
        EnvEmailPassword = "NOTIFYHUB_EMAIL_PASSWORD"
        EnvEmailFrom     = "NOTIFYHUB_EMAIL_FROM"
        EnvEmailTLS      = "NOTIFYHUB_EMAIL_TLS"

        EnvSMSProvider  = "NOTIFYHUB_SMS_PROVIDER"
        EnvSMSAPIKey    = "NOTIFYHUB_SMS_API_KEY"
        EnvSMSAPISecret = "NOTIFYHUB_SMS_API_SECRET"

        EnvTimeout       = "NOTIFYHUB_TIMEOUT"
        EnvRetryMaxCount = "NOTIFYHUB_RETRY_MAX_COUNT"
        EnvQueueType     = "NOTIFYHUB_QUEUE_TYPE"
        EnvQueueSize     = "NOTIFYHUB_QUEUE_SIZE"
        EnvWorkers       = "NOTIFYHUB_WORKERS"
)

// LoadFromEnv creates a configuration from environment variables
func LoadFromEnv() []HubOption <span class="cov0" title="0">{
        // This would read from environment variables and build configuration
        // For now, return default config
        return DefaultConfig()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package notifyhub

import (
        "fmt"
)

// Public error types that users might encounter
// These provide a stable error interface for the public API

// NotifyError represents a NotifyHub-specific error
type NotifyError struct {
        Code     string `json:"code"`
        Message  string `json:"message"`
        Platform string `json:"platform,omitempty"`
        Target   string `json:"target,omitempty"`
        Cause    error  `json:"-"` // Original error (not serialized)
}

func (e *NotifyError) Error() string <span class="cov8" title="1">{
        if e.Platform != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s:%s] %s", e.Code, e.Platform, e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%s] %s", e.Code, e.Message)</span>
}

func (e *NotifyError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Error codes for type-safe error handling
const (
        // Configuration errors
        ErrorCodeInvalidConfig = "INVALID_CONFIG"
        ErrorCodeMissingConfig = "MISSING_CONFIG"

        // Hub errors
        ErrorCodeHubClosed       = "HUB_CLOSED"
        ErrorCodeInvalidMessage  = "INVALID_MESSAGE"
        ErrorCodeInvalidPlatform = "INVALID_PLATFORM"

        // Message validation errors
        ErrorCodeEmptyMessage    = "EMPTY_MESSAGE"
        ErrorCodeInvalidFormat   = "INVALID_FORMAT"
        ErrorCodeMessageTooLarge = "MESSAGE_TOO_LARGE"
        ErrorCodeInvalidTemplate = "INVALID_TEMPLATE"

        // Target validation errors
        ErrorCodeInvalidTarget  = "INVALID_TARGET"
        ErrorCodeEmptyTarget    = "EMPTY_TARGET"
        ErrorCodeNoTargets      = "NO_TARGETS"
        ErrorCodeInvalidEmail   = "INVALID_EMAIL"
        ErrorCodeInvalidPhone   = "INVALID_PHONE"
        ErrorCodeInvalidWebhook = "INVALID_WEBHOOK"

        // Platform errors
        ErrorCodePlatformNotFound = "PLATFORM_NOT_FOUND"
        ErrorCodePlatformDown     = "PLATFORM_DOWN"
        ErrorCodeUnauthorized     = "UNAUTHORIZED"
        ErrorCodeRateLimited      = "RATE_LIMITED"
        ErrorCodeQuotaExceeded    = "QUOTA_EXCEEDED"

        // Network and transport errors
        ErrorCodeNetworkError     = "NETWORK_ERROR"
        ErrorCodeTimeout          = "TIMEOUT"
        ErrorCodeConnectionFailed = "CONNECTION_FAILED"

        // Processing errors
        ErrorCodeProcessingFailed  = "PROCESSING_FAILED"
        ErrorCodeDispatchFailed    = "DISPATCH_FAILED"
        ErrorCodeQueueFull         = "QUEUE_FULL"
        ErrorCodeWorkerUnavailable = "WORKER_UNAVAILABLE"

        // Template errors
        ErrorCodeTemplateNotFound     = "TEMPLATE_NOT_FOUND"
        ErrorCodeTemplateRenderFailed = "TEMPLATE_RENDER_FAILED"
        ErrorCodeMissingVariable      = "MISSING_VARIABLE"
)

// Predefined error instances for common scenarios
var (
        // Configuration errors
        ErrInvalidConfig = &amp;NotifyError{
                Code:    ErrorCodeInvalidConfig,
                Message: "Invalid configuration provided",
        }

        ErrMissingConfig = &amp;NotifyError{
                Code:    ErrorCodeMissingConfig,
                Message: "Required configuration is missing",
        }

        // Message validation errors
        ErrEmptyMessage = &amp;NotifyError{
                Code:    ErrorCodeEmptyMessage,
                Message: "Message cannot be empty (must have title or body)",
        }

        ErrMessageTooLarge = &amp;NotifyError{
                Code:    ErrorCodeMessageTooLarge,
                Message: "Message exceeds maximum size limit",
        }

        // Target validation errors
        ErrNoTargets = &amp;NotifyError{
                Code:    ErrorCodeNoTargets,
                Message: "At least one target must be specified",
        }

        ErrInvalidTarget = &amp;NotifyError{
                Code:    ErrorCodeInvalidTarget,
                Message: "Invalid target format",
        }

        // Platform errors
        ErrPlatformNotFound = &amp;NotifyError{
                Code:    ErrorCodePlatformNotFound,
                Message: "Specified platform is not available",
        }

        ErrUnauthorized = &amp;NotifyError{
                Code:    ErrorCodeUnauthorized,
                Message: "Unauthorized access to platform",
        }

        ErrRateLimited = &amp;NotifyError{
                Code:    ErrorCodeRateLimited,
                Message: "Rate limit exceeded",
        }

        // Network errors
        ErrNetworkError = &amp;NotifyError{
                Code:    ErrorCodeNetworkError,
                Message: "Network communication failed",
        }

        ErrTimeout = &amp;NotifyError{
                Code:    ErrorCodeTimeout,
                Message: "Operation timed out",
        }

        // Processing errors
        ErrProcessingFailed = &amp;NotifyError{
                Code:    ErrorCodeProcessingFailed,
                Message: "Message processing failed",
        }

        ErrQueueFull = &amp;NotifyError{
                Code:    ErrorCodeQueueFull,
                Message: "Message queue is full",
        }
)

// Error constructor functions

// NewConfigError creates a new configuration error
func NewConfigError(message, platform string, cause error) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:     ErrorCodeInvalidConfig,
                Message:  message,
                Platform: platform,
                Cause:    cause,
        }
}</span>

// NewValidationError creates a new validation error
func NewValidationError(message, target string) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:    ErrorCodeInvalidTarget,
                Message: message,
                Target:  target,
        }
}</span>

// NewPlatformError creates a new platform-specific error
func NewPlatformError(code, message, platform string, cause error) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:     code,
                Message:  message,
                Platform: platform,
                Cause:    cause,
        }
}</span>

// NewTargetError creates a new target-specific error
func NewTargetError(code, message, target string, cause error) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:    code,
                Message: message,
                Target:  target,
                Cause:   cause,
        }
}</span>

// NewNetworkError creates a new network error
func NewNetworkError(message string, cause error) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:    ErrorCodeNetworkError,
                Message: message,
                Cause:   cause,
        }
}</span>

// NewTimeoutError creates a new timeout error
func NewTimeoutError(message string, platform string) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:     ErrorCodeTimeout,
                Message:  message,
                Platform: platform,
        }
}</span>

// NewProcessingError creates a new processing error
func NewProcessingError(message string, cause error) *NotifyError <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:    ErrorCodeProcessingFailed,
                Message: message,
                Cause:   cause,
        }
}</span>

// Error checking functions for type-safe error handling

// IsConfigError checks if the error is a configuration error
func IsConfigError(err error) bool <span class="cov8" title="1">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov8" title="1">{
                return notifyErr.Code == ErrorCodeInvalidConfig ||
                        notifyErr.Code == ErrorCodeMissingConfig ||
                        notifyErr.Code == ErrorCodeInvalidPlatform
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsValidationError checks if the error is a validation error
func IsValidationError(err error) bool <span class="cov8" title="1">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov8" title="1">{
                return notifyErr.Code == ErrorCodeInvalidMessage ||
                        notifyErr.Code == ErrorCodeEmptyMessage ||
                        notifyErr.Code == ErrorCodeInvalidFormat ||
                        notifyErr.Code == ErrorCodeMessageTooLarge ||
                        notifyErr.Code == ErrorCodeInvalidTarget ||
                        notifyErr.Code == ErrorCodeEmptyTarget ||
                        notifyErr.Code == ErrorCodeNoTargets ||
                        notifyErr.Code == ErrorCodeInvalidEmail ||
                        notifyErr.Code == ErrorCodeInvalidPhone ||
                        notifyErr.Code == ErrorCodeInvalidWebhook
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsNetworkError checks if the error is a network-related error
func IsNetworkError(err error) bool <span class="cov0" title="0">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                return notifyErr.Code == ErrorCodeNetworkError ||
                        notifyErr.Code == ErrorCodeTimeout ||
                        notifyErr.Code == ErrorCodeConnectionFailed
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsRateLimitError checks if the error is a rate limiting error
func IsRateLimitError(err error) bool <span class="cov0" title="0">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                return notifyErr.Code == ErrorCodeRateLimited ||
                        notifyErr.Code == ErrorCodeQuotaExceeded
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsRetryableError checks if the error indicates the operation should be retried
func IsRetryableError(err error) bool <span class="cov8" title="1">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov8" title="1">{
                return notifyErr.Code == ErrorCodeNetworkError ||
                        notifyErr.Code == ErrorCodeTimeout ||
                        notifyErr.Code == ErrorCodeConnectionFailed ||
                        notifyErr.Code == ErrorCodeRateLimited ||
                        notifyErr.Code == ErrorCodePlatformDown ||
                        notifyErr.Code == ErrorCodeQueueFull
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsTemporaryError checks if the error is temporary (similar to retryable)
func IsTemporaryError(err error) bool <span class="cov8" title="1">{
        return IsRetryableError(err)
}</span>

// IsPlatformError checks if the error is platform-specific
func IsPlatformError(err error) bool <span class="cov8" title="1">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov8" title="1">{
                return notifyErr.Platform != ""
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsTargetError checks if the error is target-specific
func IsTargetError(err error) bool <span class="cov0" title="0">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                return notifyErr.Target != ""
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetErrorCode extracts the error code from a NotifyError
func GetErrorCode(err error) string <span class="cov8" title="1">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov8" title="1">{
                return notifyErr.Code
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetErrorPlatform extracts the platform from a NotifyError
func GetErrorPlatform(err error) string <span class="cov0" title="0">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                return notifyErr.Platform
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetErrorTarget extracts the target from a NotifyError
func GetErrorTarget(err error) string <span class="cov0" title="0">{
        if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                return notifyErr.Target
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// WrapError wraps an existing error with NotifyHub error information
func WrapError(code, message string, cause error) error <span class="cov0" title="0">{
        return &amp;NotifyError{
                Code:    code,
                Message: message,
                Cause:   cause,
        }
}</span>

// ErrorSummary provides a summary of multiple errors
type ErrorSummary struct {
        Total      int            `json:"total"`
        ByCode     map[string]int `json:"by_code"`
        ByPlatform map[string]int `json:"by_platform"`
        Errors     []*NotifyError `json:"errors"`
}

// NewErrorSummary creates a summary from a list of errors
func NewErrorSummary(errors []error) *ErrorSummary <span class="cov0" title="0">{
        summary := &amp;ErrorSummary{
                Total:      len(errors),
                ByCode:     make(map[string]int),
                ByPlatform: make(map[string]int),
                Errors:     make([]*NotifyError, 0),
        }

        for _, err := range errors </span><span class="cov0" title="0">{
                if notifyErr, ok := err.(*NotifyError); ok </span><span class="cov0" title="0">{
                        summary.Errors = append(summary.Errors, notifyErr)
                        summary.ByCode[notifyErr.Code]++
                        if notifyErr.Platform != "" </span><span class="cov0" title="0">{
                                summary.ByPlatform[notifyErr.Platform]++
                        }</span>
                }
        }

        <span class="cov0" title="0">return summary</span>
}

// String returns a string representation of the error summary
func (es *ErrorSummary) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("ErrorSummary: %d total errors", es.Total)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package notifyhub provides the public API for the NotifyHub notification system
package notifyhub

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/kart-io/notifyhub/internal/platform"
)

// Hub is the main interface for sending notifications
type Hub interface {
        // Send sends a message synchronously
        Send(ctx context.Context, message *Message) (*Receipt, error)

        // SendAsync sends a message asynchronously
        SendAsync(ctx context.Context, message *Message) (*AsyncReceipt, error)

        // Health checks the health status of all platforms
        Health(ctx context.Context) (*HealthStatus, error)

        // Close gracefully shuts down the hub
        Close(ctx context.Context) error
}

// HealthStatus represents the overall health status
type HealthStatus struct {
        Healthy   bool                      `json:"healthy"`
        Status    string                    `json:"status"`
        Platforms map[string]PlatformHealth `json:"platforms"`
        Queue     QueueHealth               `json:"queue"`
        Timestamp time.Time                 `json:"timestamp"`
}

// PlatformHealth represents the health of a single platform
type PlatformHealth struct {
        Available bool              `json:"available"`
        Status    string            `json:"status"`
        Details   map[string]string `json:"details,omitempty"`
}

// QueueHealth represents the health of the queue system
type QueueHealth struct {
        Available bool `json:"available"`
}

// hubImpl implements the Hub interface
type hubImpl struct {
        platformManager platform.Manager
        config          *HubConfig
        mutex           sync.RWMutex
        closed          bool
}

// Configuration types are defined in options.go

// NewHub creates a new notification hub with the given options
func NewHub(opts ...HubOption) (Hub, error) <span class="cov8" title="1">{
        config := &amp;HubConfig{
                Platforms:      make(map[string]PlatformConfig),
                DefaultTimeout: 30 * time.Second,
                RetryPolicy: RetryPolicy{
                        MaxRetries:      3,
                        InitialInterval: 1 * time.Second,
                        Multiplier:      2.0,
                        MaxInterval:     30 * time.Second,
                },
        }

        // Apply options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        // Create platform manager and register platforms
        <span class="cov8" title="1">manager := platform.NewManager(
                platform.NewDefaultSenderFactory(),
                platform.NewDefaultTargetResolver(),
                platform.NewDefaultMessageConverter(),
                platform.NewDefaultValidator(),
        )

        // Register platforms based on configuration
        for name, platformConfig := range config.Platforms </span><span class="cov8" title="1">{
                if !platformConfig.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">sender, err := createPlatformSender(name, platformConfig.Settings)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create platform %s: %w", name, err)
                }</span>

                <span class="cov8" title="1">if err := manager.RegisterSender(sender); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register platform %s: %w", name, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;hubImpl{
                platformManager: manager,
                config:          config,
        }, nil</span>
}

// Send sends a message synchronously
func (h *hubImpl) Send(ctx context.Context, message *Message) (*Receipt, error) <span class="cov8" title="1">{
        h.mutex.RLock()
        if h.closed </span><span class="cov8" title="1">{
                h.mutex.RUnlock()
                return nil, &amp;NotifyError{Code: ErrorCodeHubClosed, Message: "hub is closed"}
        }</span>
        <span class="cov8" title="1">h.mutex.RUnlock()

        // Set timeout if specified
        if h.config.DefaultTimeout &gt; 0 </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, h.config.DefaultTimeout)
                defer cancel()
        }</span>

        // Validate message
        <span class="cov8" title="1">if err := h.validateMessage(message); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;NotifyError{Code: ErrorCodeInvalidMessage, Message: "message validation failed", Cause: err}
        }</span>

        // Create target resolver
        <span class="cov8" title="1">resolver := platform.NewDefaultTargetResolver()

        // Convert targets to internal format for resolver
        targetsInterface := make([]interface{}, len(message.Targets))
        for i, target := range message.Targets </span><span class="cov8" title="1">{
                targetsInterface[i] = map[string]interface{}{
                        "type":     target.Type,
                        "value":    target.Value,
                        "platform": target.Platform,
                }
        }</span>

        // Resolve targets to platforms
        <span class="cov8" title="1">platformTargets := resolver.ResolveTargets(targetsInterface)

        // Send to all platforms
        var allResults []*platform.SendResult
        for _, targets := range platformTargets </span><span class="cov8" title="1">{
                // Convert message to internal format
                internalMsg := &amp;platform.InternalMessage{
                        ID:           message.ID,
                        Title:        message.Title,
                        Body:         message.Body,
                        Format:       message.Format,
                        Priority:     int(message.Priority),
                        Metadata:     message.Metadata,
                        Variables:    message.Variables,
                        PlatformData: message.PlatformData,
                }
                if message.ScheduledAt != nil </span><span class="cov0" title="0">{
                        internalMsg.ScheduledAt = message.ScheduledAt
                }</span>

                <span class="cov8" title="1">err := error(nil)
                if err != nil </span><span class="cov0" title="0">{
                        // Create failed result
                        for _, target := range targets </span><span class="cov0" title="0">{
                                result := platform.NewSendResult(target, false)
                                result.Error = fmt.Sprintf("message conversion failed: %v", err)
                                allResults = append(allResults, result)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">results, err := h.platformManager.SendToAll(ctx, internalMsg, targets)
                if err != nil </span><span class="cov0" title="0">{
                        // Create failed results if platform send failed completely
                        for _, target := range targets </span><span class="cov0" title="0">{
                                result := platform.NewSendResult(target, false)
                                result.Error = fmt.Sprintf("platform send failed: %v", err)
                                allResults = append(allResults, result)
                        }</span>
                } else<span class="cov8" title="1"> {
                        allResults = append(allResults, results...)
                }</span>
        }

        // Convert results to receipt
        <span class="cov8" title="1">receipt := h.buildReceipt(message.ID, allResults)
        return receipt, nil</span>
}

// SendAsync sends a message asynchronously
func (h *hubImpl) SendAsync(ctx context.Context, message *Message) (*AsyncReceipt, error) <span class="cov8" title="1">{
        h.mutex.RLock()
        if h.closed </span><span class="cov8" title="1">{
                h.mutex.RUnlock()
                return nil, &amp;NotifyError{Code: ErrorCodeHubClosed, Message: "hub is closed"}
        }</span>
        <span class="cov8" title="1">h.mutex.RUnlock()

        // For now, implement as synchronous send
        // TODO: Implement actual async processing with queue
        _, err := h.Send(ctx, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;AsyncReceipt{
                MessageID: message.ID,
                Status:    "processed", // Would be "queued" for real async
                QueuedAt:  time.Now(),
        }, nil</span>
}

// Health checks the health status of all platforms
func (h *hubImpl) Health(ctx context.Context) (*HealthStatus, error) <span class="cov8" title="1">{
        h.mutex.RLock()
        if h.closed </span><span class="cov8" title="1">{
                h.mutex.RUnlock()
                return nil, &amp;NotifyError{Code: ErrorCodeHubClosed, Message: "hub is closed"}
        }</span>
        <span class="cov8" title="1">h.mutex.RUnlock()

        platformHealth := h.platformManager.HealthCheck(ctx)

        platforms := make(map[string]PlatformHealth)
        overall := true

        for name, err := range platformHealth </span><span class="cov0" title="0">{
                available := err == nil
                if !available </span><span class="cov0" title="0">{
                        overall = false
                }</span>

                <span class="cov0" title="0">status := "healthy"
                if !available </span><span class="cov0" title="0">{
                        status = "unhealthy"
                }</span>

                <span class="cov0" title="0">platforms[name] = PlatformHealth{
                        Available: available,
                        Status:    status,
                        Details:   map[string]string{},
                }

                if err != nil </span><span class="cov0" title="0">{
                        platforms[name].Details["error"] = err.Error()
                }</span>
        }

        <span class="cov8" title="1">status := "healthy"
        if !overall </span><span class="cov0" title="0">{
                status = "degraded"
        }</span>

        <span class="cov8" title="1">return &amp;HealthStatus{
                Healthy:   overall,
                Status:    status,
                Platforms: platforms,
                Queue: QueueHealth{
                        Available: true, // TODO: Check actual queue health
                },
                Timestamp: time.Now(),
        }, nil</span>
}

// Close gracefully shuts down the hub
func (h *hubImpl) Close(ctx context.Context) error <span class="cov8" title="1">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        if h.closed </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">h.closed = true

        // Close platform manager
        if err := h.platformManager.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close platform manager: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMessage validates a message for general requirements
func (h *hubImpl) validateMessage(message *Message) error <span class="cov8" title="1">{
        if message == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("message cannot be nil")
        }</span>

        <span class="cov8" title="1">if message.Title == "" &amp;&amp; message.Body == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("message must have either title or body")
        }</span>

        <span class="cov8" title="1">if len(message.Targets) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("message must have at least one target")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// buildReceipt converts platform results to a receipt
func (h *hubImpl) buildReceipt(messageID string, results []*platform.SendResult) *Receipt <span class="cov8" title="1">{
        var successful, failed int
        var errors []string
        platformResults := make([]PlatformResult, len(results))

        for i, result := range results </span><span class="cov8" title="1">{
                if result.Success </span><span class="cov8" title="1">{
                        successful++
                }</span> else<span class="cov8" title="1"> {
                        failed++
                        if result.Error != "" </span><span class="cov8" title="1">{
                                errors = append(errors, result.Error)
                        }</span>
                }

                <span class="cov8" title="1">platformResults[i] = PlatformResult{
                        Platform: result.Target.Platform,
                        Target: Target{
                                Type:     result.Target.Type,
                                Value:    result.Target.Value,
                                Platform: result.Target.Platform,
                        },
                        Success:   result.Success,
                        Error:     result.Error,
                        MessageID: result.MessageID,
                        SentAt:    result.SentAt,
                        Duration:  result.Duration,
                        Metadata:  make(map[string]string),
                }

                // Copy metadata
                for k, v := range result.Metadata </span><span class="cov0" title="0">{
                        platformResults[i].Metadata[k] = v
                }</span>
        }

        <span class="cov8" title="1">status := StatusSuccess
        if successful == 0 </span><span class="cov8" title="1">{
                status = StatusFailed
        }</span> else<span class="cov8" title="1"> if failed &gt; 0 </span><span class="cov8" title="1">{
                status = StatusPartial
        }</span>

        // Convert string errors to error types
        <span class="cov8" title="1">errorList := make([]error, len(errors))
        for i, errStr := range errors </span><span class="cov8" title="1">{
                errorList[i] = fmt.Errorf("%s", errStr)
        }</span>

        <span class="cov8" title="1">return &amp;Receipt{
                MessageID:  messageID,
                Status:     status,
                Successful: successful,
                Failed:     failed,
                Total:      successful + failed,
                Results:    platformResults,
                Errors:     errorList,
                SentAt:     time.Now(),
                Duration:   0, // Will be calculated by caller
                Metadata:   make(map[string]string),
        }</span>
}

// createPlatformSender creates a platform sender based on the platform name and settings
func createPlatformSender(platformName string, settings map[string]interface{}) (platform.Sender, error) <span class="cov8" title="1">{
        factory := platform.NewDefaultSenderFactory()

        // Validate configuration first
        if err := factory.ValidateConfig(platformName, settings); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration for platform %s: %w", platformName, err)
        }</span>

        // Create sender
        <span class="cov8" title="1">sender, err := factory.CreateSender(platformName, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sender for platform %s: %w", platformName, err)
        }</span>

        <span class="cov8" title="1">return sender, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package notifyhub provides the public API for the NotifyHub notification system
package notifyhub

import (
        "crypto/rand"
        "fmt"
        "time"
)

// Message represents a notification message with fluent API support
type Message struct {
        ID           string                 `json:"id"`
        Title        string                 `json:"title"`
        Body         string                 `json:"body"`
        Format       string                 `json:"format"` // "text", "markdown", "html"
        Priority     Priority               `json:"priority"`
        Targets      []Target               `json:"targets"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
        Variables    map[string]interface{} `json:"variables,omitempty"`
        ScheduledAt  *time.Time             `json:"scheduled_at,omitempty"`
        PlatformData map[string]interface{} `json:"platform_data,omitempty"`
}

// Priority represents message priority levels
type Priority int

const (
        PriorityLow    Priority = 1
        PriorityNormal Priority = 2
        PriorityHigh   Priority = 3
        PriorityUrgent Priority = 4
)

// String returns the string representation of priority
func (p Priority) String() string <span class="cov0" title="0">{
        switch p </span>{
        case PriorityLow:<span class="cov0" title="0">
                return "low"</span>
        case PriorityNormal:<span class="cov0" title="0">
                return "normal"</span>
        case PriorityHigh:<span class="cov0" title="0">
                return "high"</span>
        case PriorityUrgent:<span class="cov0" title="0">
                return "urgent"</span>
        default:<span class="cov0" title="0">
                return "normal"</span>
        }
}

// MessageBuilder provides fluent API for building messages
type MessageBuilder struct {
        message *Message
}

// NewMessage creates a new message builder with optional title
func NewMessage(title ...string) *MessageBuilder <span class="cov8" title="1">{
        msg := &amp;Message{
                ID:           generateMessageID(),
                Format:       "text",
                Priority:     PriorityNormal,
                Targets:      make([]Target, 0),
                Metadata:     make(map[string]interface{}),
                Variables:    make(map[string]interface{}),
                PlatformData: make(map[string]interface{}),
        }

        if len(title) &gt; 0 </span><span class="cov8" title="1">{
                msg.Title = title[0]
        }</span>

        <span class="cov8" title="1">return &amp;MessageBuilder{message: msg}</span>
}

// NewAlert creates a new alert message (high priority by default)
func NewAlert(title string) *MessageBuilder <span class="cov8" title="1">{
        return NewMessage(title).WithPriority(PriorityHigh)
}</span>

// NewUrgent creates a new urgent message (urgent priority by default)
func NewUrgent(title string) *MessageBuilder <span class="cov8" title="1">{
        return NewMessage(title).WithPriority(PriorityUrgent)
}</span>

// WithTitle sets the message title
func (b *MessageBuilder) WithTitle(title string) *MessageBuilder <span class="cov0" title="0">{
        b.message.Title = title
        return b
}</span>

// WithBody sets the message body
func (b *MessageBuilder) WithBody(body string) *MessageBuilder <span class="cov8" title="1">{
        b.message.Body = body
        return b
}</span>

// WithText is an alias for WithBody for text messages
func (b *MessageBuilder) WithText(text string) *MessageBuilder <span class="cov8" title="1">{
        return b.WithBody(text)
}</span>

// WithFormat sets the message format
func (b *MessageBuilder) WithFormat(format string) *MessageBuilder <span class="cov0" title="0">{
        b.message.Format = format
        return b
}</span>

// WithMarkdown sets the message format to markdown and sets the body
func (b *MessageBuilder) WithMarkdown(content string) *MessageBuilder <span class="cov8" title="1">{
        b.message.Format = "markdown"
        b.message.Body = content
        return b
}</span>

// WithHTML sets the message format to HTML and sets the body
func (b *MessageBuilder) WithHTML(content string) *MessageBuilder <span class="cov8" title="1">{
        b.message.Format = "html"
        b.message.Body = content
        return b
}</span>

// WithPriority sets the message priority
func (b *MessageBuilder) WithPriority(priority Priority) *MessageBuilder <span class="cov8" title="1">{
        b.message.Priority = priority
        return b
}</span>

// WithMetadata adds metadata to the message
func (b *MessageBuilder) WithMetadata(key string, value interface{}) *MessageBuilder <span class="cov8" title="1">{
        b.message.Metadata[key] = value
        return b
}</span>

// WithVariable adds a template variable
func (b *MessageBuilder) WithVariable(key string, value interface{}) *MessageBuilder <span class="cov8" title="1">{
        b.message.Variables[key] = value
        return b
}</span>

// WithVariables adds multiple template variables
func (b *MessageBuilder) WithVariables(variables map[string]interface{}) *MessageBuilder <span class="cov0" title="0">{
        for k, v := range variables </span><span class="cov0" title="0">{
                b.message.Variables[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}

// ScheduleAt schedules the message for later delivery
func (b *MessageBuilder) ScheduleAt(when time.Time) *MessageBuilder <span class="cov8" title="1">{
        b.message.ScheduledAt = &amp;when
        return b
}</span>

// ScheduleIn schedules the message for delivery after a duration
func (b *MessageBuilder) ScheduleIn(duration time.Duration) *MessageBuilder <span class="cov8" title="1">{
        when := time.Now().Add(duration)
        b.message.ScheduledAt = &amp;when
        return b
}</span>

// ToTarget adds a generic target
func (b *MessageBuilder) ToTarget(target Target) *MessageBuilder <span class="cov0" title="0">{
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// ToTargets adds multiple targets
func (b *MessageBuilder) ToTargets(targets ...Target) *MessageBuilder <span class="cov0" title="0">{
        b.message.Targets = append(b.message.Targets, targets...)
        return b
}</span>

// ToEmail adds an email target
func (b *MessageBuilder) ToEmail(email string) *MessageBuilder <span class="cov8" title="1">{
        target := NewEmailTarget(email)
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// ToPhone adds a phone/SMS target
func (b *MessageBuilder) ToPhone(phone string) *MessageBuilder <span class="cov8" title="1">{
        target := NewPhoneTarget(phone)
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// ToFeishu adds a Feishu target (can be user, group, or webhook)
func (b *MessageBuilder) ToFeishu(identifier string) *MessageBuilder <span class="cov8" title="1">{
        target := AutoDetectTarget(identifier)
        if target.Platform == "" </span><span class="cov0" title="0">{
                target.Platform = "feishu"
        }</span>
        <span class="cov8" title="1">b.message.Targets = append(b.message.Targets, target)
        return b</span>
}

// ToFeishuUser adds a specific Feishu user target
func (b *MessageBuilder) ToFeishuUser(userID string) *MessageBuilder <span class="cov0" title="0">{
        target := NewFeishuUserTarget(userID)
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// ToFeishuGroup adds a specific Feishu group target
func (b *MessageBuilder) ToFeishuGroup(groupID string) *MessageBuilder <span class="cov8" title="1">{
        target := NewFeishuGroupTarget(groupID)
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// ToWebhook adds a webhook target
func (b *MessageBuilder) ToWebhook(url string) *MessageBuilder <span class="cov0" title="0">{
        target := NewWebhookTarget(url)
        b.message.Targets = append(b.message.Targets, target)
        return b
}</span>

// Platform-specific fluent methods

// WithFeishuCard adds Feishu card content
func (b *MessageBuilder) WithFeishuCard(card interface{}) *MessageBuilder <span class="cov8" title="1">{
        b.message.PlatformData["feishu_card"] = card
        return b
}</span>

// WithFeishuMentions adds Feishu user mentions
func (b *MessageBuilder) WithFeishuMentions(userIDs ...string) *MessageBuilder <span class="cov0" title="0">{
        mentions := make([]map[string]interface{}, len(userIDs))
        for i, userID := range userIDs </span><span class="cov0" title="0">{
                mentions[i] = map[string]interface{}{"user_id": userID}
        }</span>
        <span class="cov0" title="0">b.message.PlatformData["feishu_mentions"] = mentions
        return b</span>
}

// WithFeishuMentionAll adds Feishu mention all
func (b *MessageBuilder) WithFeishuMentionAll() *MessageBuilder <span class="cov0" title="0">{
        b.message.PlatformData["feishu_mention_all"] = true
        return b
}</span>

// WithEmailCC adds email CC recipients
func (b *MessageBuilder) WithEmailCC(emails ...string) *MessageBuilder <span class="cov8" title="1">{
        b.message.PlatformData["email_cc"] = emails
        return b
}</span>

// WithEmailBCC adds email BCC recipients
func (b *MessageBuilder) WithEmailBCC(emails ...string) *MessageBuilder <span class="cov0" title="0">{
        b.message.PlatformData["email_bcc"] = emails
        return b
}</span>

// WithEmailPriority sets email priority
func (b *MessageBuilder) WithEmailPriority(priority string) *MessageBuilder <span class="cov0" title="0">{
        b.message.PlatformData["email_priority"] = priority
        return b
}</span>

// WithEmailAttachments adds email attachments
func (b *MessageBuilder) WithEmailAttachments(attachments []string) *MessageBuilder <span class="cov0" title="0">{
        b.message.PlatformData["email_attachments"] = attachments
        return b
}</span>

// WithSMSTemplate sets SMS template ID
func (b *MessageBuilder) WithSMSTemplate(templateID string) *MessageBuilder <span class="cov8" title="1">{
        b.message.PlatformData["sms_template"] = templateID
        return b
}</span>

// WithSMSVariables sets SMS template variables
func (b *MessageBuilder) WithSMSVariables(variables map[string]interface{}) *MessageBuilder <span class="cov0" title="0">{
        b.message.PlatformData["sms_variables"] = variables
        return b
}</span>

// Build returns the constructed message
func (b *MessageBuilder) Build() *Message <span class="cov8" title="1">{
        // Generate ID if not set
        if b.message.ID == "" </span><span class="cov0" title="0">{
                b.message.ID = generateMessageID()
        }</span>

        <span class="cov8" title="1">return b.message</span>
}

// Helper methods for the Message type

// GetMetadata returns a copy of the metadata
func (m *Message) GetMetadata() map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range m.Metadata </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetVariables returns a copy of the variables
func (m *Message) GetVariables() map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range m.Variables </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetPlatformData returns a copy of the platform data
func (m *Message) GetPlatformData() map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range m.PlatformData </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AddTarget adds a target to the message
func (m *Message) AddTarget(target Target) <span class="cov0" title="0">{
        m.Targets = append(m.Targets, target)
}</span>

// AddTargets adds multiple targets to the message
func (m *Message) AddTargets(targets ...Target) <span class="cov0" title="0">{
        m.Targets = append(m.Targets, targets...)
}</span>

// SetMetadata sets a metadata value
func (m *Message) SetMetadata(key string, value interface{}) <span class="cov0" title="0">{
        if m.Metadata == nil </span><span class="cov0" title="0">{
                m.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">m.Metadata[key] = value</span>
}

// SetVariable sets a template variable
func (m *Message) SetVariable(key string, value interface{}) <span class="cov0" title="0">{
        if m.Variables == nil </span><span class="cov0" title="0">{
                m.Variables = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">m.Variables[key] = value</span>
}

// SetPlatformData sets platform-specific data
func (m *Message) SetPlatformData(key string, value interface{}) <span class="cov0" title="0">{
        if m.PlatformData == nil </span><span class="cov0" title="0">{
                m.PlatformData = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">m.PlatformData[key] = value</span>
}

// generateMessageID generates a unique message ID
func generateMessageID() string <span class="cov8" title="1">{
        // Generate a simple unique ID
        b := make([]byte, 8)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                // Fallback to time-based ID if random read fails
                return fmt.Sprintf("msg_fallback_%d", time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("msg_%x_%d", b, time.Now().UnixNano())</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package notifyhub

import (
        "time"
)

// Configuration options for Hub creation
// These provide a type-safe way to configure the NotifyHub

// HubConfig represents the complete configuration for a NotifyHub instance
type HubConfig struct {
        // Platform configurations
        Platforms map[string]PlatformConfig `json:"platforms"`

        // Queue configuration
        Queue QueueConfig `json:"queue"`

        // Timeouts and limits
        DefaultTimeout time.Duration `json:"default_timeout"`
        MaxMessageSize int           `json:"max_message_size"`

        // Retry configuration
        RetryPolicy RetryPolicy `json:"retry_policy"`

        // Rate limiting
        RateLimit RateLimitConfig `json:"rate_limit"`

        // Monitoring and observability
        MetricsEnabled bool              `json:"metrics_enabled"`
        TracingEnabled bool              `json:"tracing_enabled"`
        HealthCheck    HealthCheckConfig `json:"health_check"`

        // Security
        Security SecurityConfig `json:"security"`

        // General metadata
        Metadata map[string]string `json:"metadata,omitempty"`
}

// PlatformConfig represents configuration for a specific platform
type PlatformConfig struct {
        Enabled   bool                   `json:"enabled"`
        Settings  map[string]interface{} `json:"settings"`
        Timeout   time.Duration          `json:"timeout,omitempty"`
        RateLimit *RateLimitConfig       `json:"rate_limit,omitempty"`
        Retry     *RetryPolicy           `json:"retry,omitempty"`
}

// PlatformConfigOptions is an alias for backward compatibility
type PlatformConfigOptions = PlatformConfig

// QueueConfig represents queue system configuration
type QueueConfig struct {
        Type       string        `json:"type"` // "memory", "redis", "kafka"
        BufferSize int           `json:"buffer_size"`
        Workers    int           `json:"workers"`
        Timeout    time.Duration `json:"timeout,omitempty"`

        // Queue-specific settings
        Settings map[string]interface{} `json:"settings,omitempty"`

        // Persistence settings
        Persistent bool   `json:"persistent"`
        DataDir    string `json:"data_dir,omitempty"`
}

// RetryPolicy represents retry configuration
type RetryPolicy struct {
        MaxRetries      int           `json:"max_retries"`
        InitialInterval time.Duration `json:"initial_interval"`
        Multiplier      float64       `json:"multiplier"`
        MaxInterval     time.Duration `json:"max_interval"`
        Jitter          bool          `json:"jitter"` // Add randomness to prevent thundering herd
}

// RetryPolicyOptions is an alias for backward compatibility
type RetryPolicyOptions = RetryPolicy

// RateLimitConfig represents rate limiting configuration
type RateLimitConfig struct {
        Enabled     bool          `json:"enabled"`
        Rate        int           `json:"rate"`         // requests per window
        Window      time.Duration `json:"window"`       // time window
        Burst       int           `json:"burst"`        // burst capacity
        PerPlatform bool          `json:"per_platform"` // separate limits per platform
}

// HealthCheckConfig represents health check configuration
type HealthCheckConfig struct {
        Enabled  bool          `json:"enabled"`
        Interval time.Duration `json:"interval"`
        Timeout  time.Duration `json:"timeout"`
        Retries  int           `json:"retries"`
}

// SecurityConfig represents security configuration
type SecurityConfig struct {
        EncryptionEnabled bool     `json:"encryption_enabled"`
        EncryptionKey     string   `json:"encryption_key,omitempty"`
        ValidateTargets   bool     `json:"validate_targets"`
        AllowedDomains    []string `json:"allowed_domains,omitempty"`
        BlockedDomains    []string `json:"blocked_domains,omitempty"`
}

// HubOption represents a configuration option for the hub
type HubOption func(*HubConfig)

// Default configuration values
const (
        DefaultTimeout         = 30 * time.Second
        DefaultMaxMessageSize  = 1024 * 1024 // 1MB
        DefaultQueueBufferSize = 1000
        DefaultQueueWorkers    = 4
        DefaultRetryMaxRetries = 3
        DefaultRateLimit       = 100
        DefaultRateWindow      = time.Minute
)

// Platform configuration options

// WithPlatform configures a platform with custom settings
func WithPlatform(name string, config PlatformConfig) HubOption <span class="cov8" title="1">{
        return func(c *HubConfig) </span><span class="cov8" title="1">{
                if c.Platforms == nil </span><span class="cov0" title="0">{
                        c.Platforms = make(map[string]PlatformConfig)
                }</span>
                <span class="cov8" title="1">c.Platforms[name] = config</span>
        }
}

// WithFeishu configures Feishu platform with webhook URL and secret
func WithFeishu(webhookURL, secret string) HubOption <span class="cov0" title="0">{
        return WithPlatform("feishu", PlatformConfig{
                Enabled: true,
                Settings: map[string]interface{}{
                        "webhook_url": webhookURL,
                        "secret":      secret,
                },
        })
}</span>

// WithFeishuFromMap configures Feishu platform with settings map
func WithFeishuFromMap(settings map[string]interface{}) HubOption <span class="cov8" title="1">{
        return WithPlatform("feishu", PlatformConfig{
                Enabled:  true,
                Settings: settings,
        })
}</span>

// WithFeishuAdvanced configures Feishu with advanced settings
func WithFeishuAdvanced(webhookURL, secret string, timeout time.Duration, customSettings map[string]interface{}) HubOption <span class="cov0" title="0">{
        settings := map[string]interface{}{
                "webhook_url": webhookURL,
                "secret":      secret,
        }

        // Merge custom settings
        for k, v := range customSettings </span><span class="cov0" title="0">{
                settings[k] = v
        }</span>

        <span class="cov0" title="0">return WithPlatform("feishu", PlatformConfig{
                Enabled:  true,
                Settings: settings,
                Timeout:  timeout,
        })</span>
}

// WithEmail configures Email platform with SMTP settings
func WithEmail(host string, port int, username, password, from string) HubOption <span class="cov0" title="0">{
        return WithPlatform("email", PlatformConfig{
                Enabled: true,
                Settings: map[string]interface{}{
                        "smtp_host":     host,
                        "smtp_port":     port,
                        "smtp_username": username,
                        "smtp_password": password,
                        "smtp_from":     from,
                        "smtp_tls":      true, // Default to TLS
                },
        })
}</span>

// WithEmailFromMap configures Email platform with settings map
func WithEmailFromMap(settings map[string]interface{}) HubOption <span class="cov8" title="1">{
        return WithPlatform("email", PlatformConfig{
                Enabled:  true,
                Settings: settings,
        })
}</span>

// WithEmailAdvanced configures Email with advanced SMTP settings
func WithEmailAdvanced(host string, port int, username, password, from string, useTLS, useSSL bool, timeout time.Duration) HubOption <span class="cov0" title="0">{
        return WithPlatform("email", PlatformConfig{
                Enabled: true,
                Settings: map[string]interface{}{
                        "smtp_host":     host,
                        "smtp_port":     port,
                        "smtp_username": username,
                        "smtp_password": password,
                        "smtp_from":     from,
                        "smtp_tls":      useTLS,
                        "smtp_ssl":      useSSL,
                },
                Timeout: timeout,
        })
}</span>

// WithSMS configures SMS platform
func WithSMS(provider, apiKey, apiSecret string) HubOption <span class="cov0" title="0">{
        return WithPlatform("sms", PlatformConfig{
                Enabled: true,
                Settings: map[string]interface{}{
                        "provider":   provider,
                        "api_key":    apiKey,
                        "api_secret": apiSecret,
                },
        })
}</span>

// WithSMSFromMap configures SMS platform with settings map
func WithSMSFromMap(settings map[string]interface{}) HubOption <span class="cov0" title="0">{
        return WithPlatform("sms", PlatformConfig{
                Enabled:  true,
                Settings: settings,
        })
}</span>

// WithWebhook configures a generic webhook platform
func WithWebhook(name, url string, headers map[string]string) HubOption <span class="cov0" title="0">{
        settings := map[string]interface{}{
                "url": url,
        }

        if headers != nil </span><span class="cov0" title="0">{
                settings["headers"] = headers
        }</span>

        <span class="cov0" title="0">return WithPlatform(name, PlatformConfig{
                Enabled:  true,
                Settings: settings,
        })</span>
}

// Queue configuration options

// WithQueue configures the queue system
func WithQueue(queueType string, bufferSize, workers int) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.Queue = QueueConfig{
                        Type:       queueType,
                        BufferSize: bufferSize,
                        Workers:    workers,
                }
        }</span>
}

// WithMemoryQueue configures an in-memory queue
func WithMemoryQueue(bufferSize, workers int) HubOption <span class="cov0" title="0">{
        return WithQueue("memory", bufferSize, workers)
}</span>

// WithRedisQueue configures a Redis-based queue
func WithRedisQueue(redisURL string, bufferSize, workers int) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.Queue = QueueConfig{
                        Type:       "redis",
                        BufferSize: bufferSize,
                        Workers:    workers,
                        Settings: map[string]interface{}{
                                "redis_url": redisURL,
                        },
                }
        }</span>
}

// WithPersistentQueue enables queue persistence
func WithPersistentQueue(dataDir string) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.Queue.Persistent = true
                c.Queue.DataDir = dataDir
        }</span>
}

// Retry configuration options

// WithRetryPolicy configures the global retry policy
func WithRetryPolicy(policy RetryPolicy) HubOption <span class="cov8" title="1">{
        return func(c *HubConfig) </span><span class="cov8" title="1">{
                c.RetryPolicy = policy
        }</span>
}

// WithRetry configures retry with simple parameters
func WithRetry(maxRetries int, initialInterval time.Duration, multiplier float64) HubOption <span class="cov8" title="1">{
        return WithRetryPolicy(RetryPolicy{
                MaxRetries:      maxRetries,
                InitialInterval: initialInterval,
                Multiplier:      multiplier,
                MaxInterval:     initialInterval * time.Duration(maxRetries),
                Jitter:          true,
        })
}</span>

// WithNoRetry disables retry completely
func WithNoRetry() HubOption <span class="cov0" title="0">{
        return WithRetryPolicy(RetryPolicy{
                MaxRetries: 0,
        })
}</span>

// Timeout and limit options

// WithTimeout sets the default timeout for all operations
func WithTimeout(timeout time.Duration) HubOption <span class="cov8" title="1">{
        return func(c *HubConfig) </span><span class="cov8" title="1">{
                c.DefaultTimeout = timeout
        }</span>
}

// WithMaxMessageSize sets the maximum message size
func WithMaxMessageSize(maxSize int) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.MaxMessageSize = maxSize
        }</span>
}

// Rate limiting options

// WithRateLimit configures global rate limiting
func WithRateLimit(rate int, window time.Duration) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.RateLimit = RateLimitConfig{
                        Enabled: true,
                        Rate:    rate,
                        Window:  window,
                        Burst:   rate * 2, // Default burst is 2x the rate
                }
        }</span>
}

// WithRateLimitAdvanced configures advanced rate limiting
func WithRateLimitAdvanced(rate int, window time.Duration, burst int, perPlatform bool) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.RateLimit = RateLimitConfig{
                        Enabled:     true,
                        Rate:        rate,
                        Window:      window,
                        Burst:       burst,
                        PerPlatform: perPlatform,
                }
        }</span>
}

// WithNoRateLimit disables rate limiting
func WithNoRateLimit() HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.RateLimit.Enabled = false
        }</span>
}

// Monitoring options

// WithMetrics enables metrics collection
func WithMetrics(enabled bool) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.MetricsEnabled = enabled
        }</span>
}

// WithTracing enables distributed tracing
func WithTracing(enabled bool) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.TracingEnabled = enabled
        }</span>
}

// WithHealthCheck configures health check settings
func WithHealthCheck(interval, timeout time.Duration, retries int) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.HealthCheck = HealthCheckConfig{
                        Enabled:  true,
                        Interval: interval,
                        Timeout:  timeout,
                        Retries:  retries,
                }
        }</span>
}

// WithNoHealthCheck disables health checks
func WithNoHealthCheck() HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.HealthCheck.Enabled = false
        }</span>
}

// Security options

// WithSecurity configures security settings
func WithSecurity(validateTargets bool, allowedDomains, blockedDomains []string) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.Security = SecurityConfig{
                        ValidateTargets: validateTargets,
                        AllowedDomains:  allowedDomains,
                        BlockedDomains:  blockedDomains,
                }
        }</span>
}

// WithEncryption enables message encryption
func WithEncryption(enabled bool, encryptionKey string) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.Security.EncryptionEnabled = enabled
                c.Security.EncryptionKey = encryptionKey
        }</span>
}

// Metadata options

// WithMetadata sets global metadata
func WithMetadata(metadata map[string]string) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                if c.Metadata == nil </span><span class="cov0" title="0">{
                        c.Metadata = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range metadata </span><span class="cov0" title="0">{
                        c.Metadata[k] = v
                }</span>
        }
}

// WithMetadataValue sets a single metadata value
func WithMetadataValue(key, value string) HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                if c.Metadata == nil </span><span class="cov0" title="0">{
                        c.Metadata = make(map[string]string)
                }</span>
                <span class="cov0" title="0">c.Metadata[key] = value</span>
        }
}

// Preset configurations

// WithDefaults applies sensible default configuration
func WithDefaults() HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.DefaultTimeout = DefaultTimeout
                c.MaxMessageSize = DefaultMaxMessageSize
                c.Queue = QueueConfig{
                        Type:       "memory",
                        BufferSize: DefaultQueueBufferSize,
                        Workers:    DefaultQueueWorkers,
                }
                c.RetryPolicy = RetryPolicy{
                        MaxRetries:      DefaultRetryMaxRetries,
                        InitialInterval: 1 * time.Second,
                        Multiplier:      2.0,
                        MaxInterval:     30 * time.Second,
                        Jitter:          true,
                }
                c.MetricsEnabled = false
                c.TracingEnabled = false
                c.HealthCheck = HealthCheckConfig{
                        Enabled:  true,
                        Interval: 30 * time.Second,
                        Timeout:  5 * time.Second,
                        Retries:  3,
                }
        }</span>
}

// WithTestDefaults applies test-friendly configuration
func WithTestDefaults() HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.DefaultTimeout = 5 * time.Second
                c.MaxMessageSize = 1024 // Smaller for tests
                c.Queue = QueueConfig{
                        Type:       "memory",
                        BufferSize: 10,
                        Workers:    1,
                }
                c.RetryPolicy = RetryPolicy{
                        MaxRetries:      1,
                        InitialInterval: 100 * time.Millisecond,
                        Multiplier:      1.0,
                        MaxInterval:     100 * time.Millisecond,
                        Jitter:          false,
                }
                c.MetricsEnabled = false
                c.TracingEnabled = false
                c.HealthCheck.Enabled = false
        }</span>
}

// WithProductionDefaults applies production-ready configuration
func WithProductionDefaults() HubOption <span class="cov0" title="0">{
        return func(c *HubConfig) </span><span class="cov0" title="0">{
                c.DefaultTimeout = 30 * time.Second
                c.MaxMessageSize = 5 * 1024 * 1024 // 5MB
                c.Queue = QueueConfig{
                        Type:       "redis",
                        BufferSize: 10000,
                        Workers:    10,
                        Persistent: true,
                }
                c.RetryPolicy = RetryPolicy{
                        MaxRetries:      5,
                        InitialInterval: 1 * time.Second,
                        Multiplier:      2.0,
                        MaxInterval:     60 * time.Second,
                        Jitter:          true,
                }
                c.RateLimit = RateLimitConfig{
                        Enabled:     true,
                        Rate:        1000,
                        Window:      time.Minute,
                        Burst:       2000,
                        PerPlatform: true,
                }
                c.MetricsEnabled = true
                c.TracingEnabled = true
                c.HealthCheck = HealthCheckConfig{
                        Enabled:  true,
                        Interval: 15 * time.Second,
                        Timeout:  10 * time.Second,
                        Retries:  3,
                }
                c.Security = SecurityConfig{
                        ValidateTargets: true,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package notifyhub

import (
        "fmt"
        "time"
)

// Receipt represents the result of sending a message
// This provides a unified return type for Send() method with consistent API
type Receipt struct {
        MessageID  string            `json:"message_id"`         // Unique message identifier
        Status     string            `json:"status"`             // "success", "partial", "failed"
        Successful int               `json:"successful"`         // Number of successful sends
        Failed     int               `json:"failed"`             // Number of failed sends
        Total      int               `json:"total"`              // Total number of targets
        Results    []PlatformResult  `json:"results"`            // Detailed results per platform/target
        Errors     []error           `json:"errors,omitempty"`   // List of errors encountered
        SentAt     time.Time         `json:"sent_at"`            // When the message was processed
        Duration   time.Duration     `json:"duration"`           // Processing duration
        Metadata   map[string]string `json:"metadata,omitempty"` // Additional metadata
}

// PlatformResult represents the result for a specific platform/target
type PlatformResult struct {
        Platform   string            `json:"platform"`              // Platform name (feishu, email, sms)
        Target     Target            `json:"target"`                // Target information
        Success    bool              `json:"success"`               // Whether send was successful
        Error      string            `json:"error,omitempty"`       // Error message if failed
        MessageID  string            `json:"message_id,omitempty"`  // Platform-specific message ID
        SentAt     time.Time         `json:"sent_at"`               // When sent to this platform
        Duration   time.Duration     `json:"duration"`              // Time taken for this platform
        StatusCode int               `json:"status_code,omitempty"` // HTTP status code if applicable
        Response   string            `json:"response,omitempty"`    // Platform response if available
        Metadata   map[string]string `json:"metadata,omitempty"`    // Platform-specific metadata
}

// AsyncReceipt represents the result of an async send operation
type AsyncReceipt struct {
        MessageID         string            `json:"message_id"`                    // Unique message identifier
        Status            string            `json:"status"`                        // "queued", "scheduled", "processing"
        QueuedAt          time.Time         `json:"queued_at"`                     // When the message was queued
        ScheduledAt       *time.Time        `json:"scheduled_at,omitempty"`        // When scheduled to send (if applicable)
        EstimatedSendTime *time.Time        `json:"estimated_send_time,omitempty"` // Estimated processing time
        QueuePosition     int               `json:"queue_position,omitempty"`      // Position in queue
        Metadata          map[string]string `json:"metadata,omitempty"`            // Additional metadata
}

// Status constants for receipts
const (
        StatusSuccess = "success" // All targets succeeded
        StatusPartial = "partial" // Some targets succeeded, some failed
        StatusFailed  = "failed"  // All targets failed
)

// Async status constants
const (
        AsyncStatusQueued     = "queued"     // Message is queued for processing
        AsyncStatusScheduled  = "scheduled"  // Message is scheduled for future sending
        AsyncStatusProcessing = "processing" // Message is currently being processed
        AsyncStatusCompleted  = "completed"  // Async processing completed
        AsyncStatusFailed     = "failed"     // Async processing failed
)

// NewReceipt creates a new receipt with basic information
func NewReceipt(messageID string) *Receipt <span class="cov0" title="0">{
        return &amp;Receipt{
                MessageID: messageID,
                Results:   make([]PlatformResult, 0),
                Errors:    make([]error, 0),
                SentAt:    time.Now(),
                Metadata:  make(map[string]string),
        }
}</span>

// NewAsyncReceipt creates a new async receipt
func NewAsyncReceipt(messageID string, status string) *AsyncReceipt <span class="cov0" title="0">{
        return &amp;AsyncReceipt{
                MessageID: messageID,
                Status:    status,
                QueuedAt:  time.Now(),
                Metadata:  make(map[string]string),
        }
}</span>

// AddResult adds a platform result to the receipt
func (r *Receipt) AddResult(result PlatformResult) <span class="cov0" title="0">{
        r.Results = append(r.Results, result)
        r.Total++

        if result.Success </span><span class="cov0" title="0">{
                r.Successful++
        }</span> else<span class="cov0" title="0"> {
                r.Failed++
        }</span>

        // Update overall status
        <span class="cov0" title="0">r.updateStatus()</span>
}

// AddError adds an error to the receipt
func (r *Receipt) AddError(err error) <span class="cov0" title="0">{
        r.Errors = append(r.Errors, err)
}</span>

// SetDuration sets the processing duration and calculates the end time
func (r *Receipt) SetDuration(duration time.Duration) <span class="cov0" title="0">{
        r.Duration = duration
}</span>

// SetMetadata sets metadata for the receipt
func (r *Receipt) SetMetadata(key, value string) <span class="cov0" title="0">{
        if r.Metadata == nil </span><span class="cov0" title="0">{
                r.Metadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">r.Metadata[key] = value</span>
}

// IsSuccess returns true if all targets were successful
func (r *Receipt) IsSuccess() bool <span class="cov0" title="0">{
        return r.Status == StatusSuccess
}</span>

// IsPartial returns true if some targets succeeded and some failed
func (r *Receipt) IsPartial() bool <span class="cov0" title="0">{
        return r.Status == StatusPartial
}</span>

// IsFailed returns true if all targets failed
func (r *Receipt) IsFailed() bool <span class="cov0" title="0">{
        return r.Status == StatusFailed
}</span>

// GetSuccessfulResults returns only the successful platform results
func (r *Receipt) GetSuccessfulResults() []PlatformResult <span class="cov0" title="0">{
        successful := make([]PlatformResult, 0)
        for _, result := range r.Results </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        successful = append(successful, result)
                }</span>
        }
        <span class="cov0" title="0">return successful</span>
}

// GetFailedResults returns only the failed platform results
func (r *Receipt) GetFailedResults() []PlatformResult <span class="cov0" title="0">{
        failed := make([]PlatformResult, 0)
        for _, result := range r.Results </span><span class="cov0" title="0">{
                if !result.Success </span><span class="cov0" title="0">{
                        failed = append(failed, result)
                }</span>
        }
        <span class="cov0" title="0">return failed</span>
}

// GetResultsByPlatform returns results grouped by platform
func (r *Receipt) GetResultsByPlatform() map[string][]PlatformResult <span class="cov0" title="0">{
        groups := make(map[string][]PlatformResult)
        for _, result := range r.Results </span><span class="cov0" title="0">{
                groups[result.Platform] = append(groups[result.Platform], result)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

// GetAverageResponseTime returns the average response time across all platforms
func (r *Receipt) GetAverageResponseTime() time.Duration <span class="cov0" title="0">{
        if len(r.Results) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var total time.Duration
        for _, result := range r.Results </span><span class="cov0" title="0">{
                total += result.Duration
        }</span>

        <span class="cov0" title="0">return total / time.Duration(len(r.Results))</span>
}

// String returns a human-readable string representation of the receipt
func (r *Receipt) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Receipt[%s]: %s (%d/%d successful) in %v",
                r.MessageID, r.Status, r.Successful, r.Total, r.Duration)
}</span>

// updateStatus updates the overall status based on results
func (r *Receipt) updateStatus() <span class="cov0" title="0">{
        if r.Total == 0 </span><span class="cov0" title="0">{
                r.Status = StatusFailed
                return
        }</span>

        <span class="cov0" title="0">if r.Successful == r.Total </span><span class="cov0" title="0">{
                r.Status = StatusSuccess
        }</span> else<span class="cov0" title="0"> if r.Successful &gt; 0 </span><span class="cov0" title="0">{
                r.Status = StatusPartial
        }</span> else<span class="cov0" title="0"> {
                r.Status = StatusFailed
        }</span>
}

// NewPlatformResult creates a new platform result
func NewPlatformResult(platform string, target Target, success bool) PlatformResult <span class="cov0" title="0">{
        return PlatformResult{
                Platform: platform,
                Target:   target,
                Success:  success,
                SentAt:   time.Now(),
                Metadata: make(map[string]string),
        }
}</span>

// SetError sets an error for the platform result
func (pr *PlatformResult) SetError(err error) <span class="cov0" title="0">{
        pr.Success = false
        pr.Error = err.Error()
}</span>

// SetSuccess marks the platform result as successful
func (pr *PlatformResult) SetSuccess(messageID string) <span class="cov0" title="0">{
        pr.Success = true
        pr.MessageID = messageID
        pr.Error = ""
}</span>

// SetDuration sets the duration for the platform result
func (pr *PlatformResult) SetDuration(duration time.Duration) <span class="cov0" title="0">{
        pr.Duration = duration
}</span>

// SetStatusCode sets the HTTP status code (if applicable)
func (pr *PlatformResult) SetStatusCode(code int) <span class="cov0" title="0">{
        pr.StatusCode = code
}</span>

// SetResponse sets the platform response
func (pr *PlatformResult) SetResponse(response string) <span class="cov0" title="0">{
        pr.Response = response
}</span>

// SetMetadata sets metadata for the platform result
func (pr *PlatformResult) SetMetadata(key, value string) <span class="cov0" title="0">{
        if pr.Metadata == nil </span><span class="cov0" title="0">{
                pr.Metadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">pr.Metadata[key] = value</span>
}

// String returns a string representation of the platform result
func (pr *PlatformResult) String() string <span class="cov0" title="0">{
        status := "✅"
        if !pr.Success </span><span class="cov0" title="0">{
                status = "❌"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s %s-&gt;%s (%s) in %v",
                status, pr.Platform, pr.Target.Value, pr.Target.Type, pr.Duration)</span>
}

// SetScheduledSendTime sets the scheduled send time for async receipt
func (ar *AsyncReceipt) SetScheduledSendTime(scheduledAt time.Time) <span class="cov0" title="0">{
        ar.ScheduledAt = &amp;scheduledAt
        ar.Status = AsyncStatusScheduled
}</span>

// SetEstimatedSendTime sets the estimated send time for async receipt
func (ar *AsyncReceipt) SetEstimatedSendTime(estimatedAt time.Time) <span class="cov0" title="0">{
        ar.EstimatedSendTime = &amp;estimatedAt
}</span>

// SetQueuePosition sets the position in queue for async receipt
func (ar *AsyncReceipt) SetQueuePosition(position int) <span class="cov0" title="0">{
        ar.QueuePosition = position
}</span>

// SetMetadata sets metadata for async receipt
func (ar *AsyncReceipt) SetMetadata(key, value string) <span class="cov0" title="0">{
        if ar.Metadata == nil </span><span class="cov0" title="0">{
                ar.Metadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">ar.Metadata[key] = value</span>
}

// String returns a string representation of the async receipt
func (ar *AsyncReceipt) String() string <span class="cov0" title="0">{
        status := ar.Status
        if ar.ScheduledAt != nil </span><span class="cov0" title="0">{
                status = fmt.Sprintf("%s (scheduled for %v)", status, ar.ScheduledAt.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("AsyncReceipt[%s]: %s", ar.MessageID, status)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package notifyhub

import (
        "fmt"
        "regexp"
        "strings"
)

// Target represents a notification target (email, user, group, etc.)
// This structure encapsulates target information for different platforms
type Target struct {
        Type     string `json:"type"`     // "email", "user", "group", "channel", "webhook", "phone"
        Value    string `json:"value"`    // email address, user ID, phone number, etc.
        Platform string `json:"platform"` // "feishu", "email", "sms", "webhook"
}

// TargetType constants for type safety
const (
        TargetTypeEmail   = "email"
        TargetTypePhone   = "phone"
        TargetTypeUser    = "user"
        TargetTypeGroup   = "group"
        TargetTypeChannel = "channel"
        TargetTypeWebhook = "webhook"
)

// Platform constants for type safety
const (
        PlatformFeishu  = "feishu"
        PlatformEmail   = "email"
        PlatformSMS     = "sms"
        PlatformWebhook = "webhook"
        PlatformAuto    = "auto" // Auto-detect platform
)

// NewTarget creates a new target with the given type, value, and platform
func NewTarget(targetType, value, platform string) Target <span class="cov8" title="1">{
        return Target{
                Type:     targetType,
                Value:    value,
                Platform: platform,
        }
}</span>

// NewEmailTarget creates a new email target
func NewEmailTarget(email string) Target <span class="cov8" title="1">{
        return Target{
                Type:     TargetTypeEmail,
                Value:    email,
                Platform: PlatformEmail,
        }
}</span>

// NewPhoneTarget creates a new phone/SMS target
func NewPhoneTarget(phoneNumber string) Target <span class="cov8" title="1">{
        return Target{
                Type:     TargetTypePhone,
                Value:    phoneNumber,
                Platform: PlatformSMS,
        }
}</span>

// NewFeishuUserTarget creates a new Feishu user target
func NewFeishuUserTarget(userID string) Target <span class="cov8" title="1">{
        return Target{
                Type:     TargetTypeUser,
                Value:    userID,
                Platform: PlatformFeishu,
        }
}</span>

// NewFeishuGroupTarget creates a new Feishu group target
func NewFeishuGroupTarget(groupID string) Target <span class="cov8" title="1">{
        return Target{
                Type:     TargetTypeGroup,
                Value:    groupID,
                Platform: PlatformFeishu,
        }
}</span>

// NewWebhookTarget creates a new webhook target
func NewWebhookTarget(webhookURL string) Target <span class="cov0" title="0">{
        platform := PlatformWebhook
        // Auto-detect platform based on URL
        if strings.Contains(webhookURL, "feishu") || strings.Contains(webhookURL, "lark") </span><span class="cov0" title="0">{
                platform = PlatformFeishu
        }</span>

        <span class="cov0" title="0">return Target{
                Type:     TargetTypeWebhook,
                Value:    webhookURL,
                Platform: platform,
        }</span>
}

// AutoDetectTarget creates a target with auto-detected type and platform
func AutoDetectTarget(value string) Target <span class="cov8" title="1">{
        targetType, platform := detectTargetTypeAndPlatform(value)
        return Target{
                Type:     targetType,
                Value:    value,
                Platform: platform,
        }
}</span>

// Validate validates the target configuration
func (t Target) Validate() error <span class="cov8" title="1">{
        if t.Value == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("target value cannot be empty")
        }</span>

        <span class="cov8" title="1">switch t.Type </span>{
        case TargetTypeEmail:<span class="cov8" title="1">
                return t.validateEmail()</span>
        case TargetTypePhone:<span class="cov8" title="1">
                return t.validatePhone()</span>
        case TargetTypeWebhook:<span class="cov0" title="0">
                return t.validateWebhook()</span>
        case TargetTypeUser, TargetTypeGroup, TargetTypeChannel:<span class="cov0" title="0">
                return t.validateID()</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported target type: %s", t.Type)</span>
        }
}

// IsEmail returns true if the target is an email
func (t Target) IsEmail() bool <span class="cov0" title="0">{
        return t.Type == TargetTypeEmail
}</span>

// IsPhone returns true if the target is a phone number
func (t Target) IsPhone() bool <span class="cov0" title="0">{
        return t.Type == TargetTypePhone
}</span>

// IsWebhook returns true if the target is a webhook
func (t Target) IsWebhook() bool <span class="cov0" title="0">{
        return t.Type == TargetTypeWebhook
}</span>

// IsFeishu returns true if the target is for Feishu platform
func (t Target) IsFeishu() bool <span class="cov0" title="0">{
        return t.Platform == PlatformFeishu
}</span>

// String returns a string representation of the target
func (t Target) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s@%s", t.Type, t.Value, t.Platform)
}</span>

// validateEmail validates email format
func (t Target) validateEmail() error <span class="cov8" title="1">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(t.Value) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid email format: %s", t.Value)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validatePhone validates phone number format
func (t Target) validatePhone() error <span class="cov8" title="1">{
        // Basic phone number validation (starts with + followed by digits)
        phoneRegex := regexp.MustCompile(`^\+[1-9]\d{1,14}$`)
        if !phoneRegex.MatchString(t.Value) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid phone number format: %s (expected format: +1234567890)", t.Value)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateWebhook validates webhook URL format
func (t Target) validateWebhook() error <span class="cov0" title="0">{
        if !strings.HasPrefix(t.Value, "http://") &amp;&amp; !strings.HasPrefix(t.Value, "https://") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid webhook URL: %s (must start with http:// or https://)", t.Value)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateID validates user/group/channel ID format
func (t Target) validateID() error <span class="cov0" title="0">{
        if len(t.Value) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ID format: %s (too short)", t.Value)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// detectTargetTypeAndPlatform automatically detects target type and platform based on value
func detectTargetTypeAndPlatform(value string) (string, string) <span class="cov8" title="1">{
        // Email detection
        if strings.Contains(value, "@") &amp;&amp; strings.Contains(value, ".") </span><span class="cov8" title="1">{
                return TargetTypeEmail, PlatformEmail
        }</span>

        // Phone number detection
        <span class="cov8" title="1">if strings.HasPrefix(value, "+") &amp;&amp; len(value) &gt; 5 </span><span class="cov8" title="1">{
                return TargetTypePhone, PlatformSMS
        }</span>

        // Webhook URL detection
        <span class="cov8" title="1">if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") </span><span class="cov8" title="1">{
                platform := PlatformWebhook
                if strings.Contains(value, "feishu") || strings.Contains(value, "lark") </span><span class="cov0" title="0">{
                        platform = PlatformFeishu
                }</span>
                <span class="cov8" title="1">return TargetTypeWebhook, platform</span>
        }

        // Channel detection (starts with #)
        <span class="cov8" title="1">if strings.HasPrefix(value, "#") </span><span class="cov0" title="0">{
                return TargetTypeChannel, PlatformAuto
        }</span>

        // User mention detection (starts with @)
        <span class="cov8" title="1">if strings.HasPrefix(value, "@") </span><span class="cov0" title="0">{
                return TargetTypeUser, PlatformAuto
        }</span>

        // Feishu ID detection
        <span class="cov8" title="1">if strings.HasPrefix(value, "oc_") || strings.HasPrefix(value, "ou_") </span><span class="cov8" title="1">{
                targetType := TargetTypeGroup
                if strings.HasPrefix(value, "ou_") </span><span class="cov8" title="1">{
                        targetType = TargetTypeUser
                }</span>
                <span class="cov8" title="1">return targetType, PlatformFeishu</span>
        }

        // Default to user type with auto platform detection
        <span class="cov8" title="1">return TargetTypeUser, PlatformAuto</span>
}

// TargetList represents a list of targets with utility methods
type TargetList []Target

// Add adds a target to the list
func (tl *TargetList) Add(target Target) <span class="cov0" title="0">{
        *tl = append(*tl, target)
}</span>

// AddEmail adds an email target to the list
func (tl *TargetList) AddEmail(email string) <span class="cov0" title="0">{
        tl.Add(NewEmailTarget(email))
}</span>

// AddPhone adds a phone target to the list
func (tl *TargetList) AddPhone(phoneNumber string) <span class="cov0" title="0">{
        tl.Add(NewPhoneTarget(phoneNumber))
}</span>

// AddFeishuUser adds a Feishu user target to the list
func (tl *TargetList) AddFeishuUser(userID string) <span class="cov0" title="0">{
        tl.Add(NewFeishuUserTarget(userID))
}</span>

// AddFeishuGroup adds a Feishu group target to the list
func (tl *TargetList) AddFeishuGroup(groupID string) <span class="cov0" title="0">{
        tl.Add(NewFeishuGroupTarget(groupID))
}</span>

// AddWebhook adds a webhook target to the list
func (tl *TargetList) AddWebhook(webhookURL string) <span class="cov0" title="0">{
        tl.Add(NewWebhookTarget(webhookURL))
}</span>

// GroupByPlatform groups targets by platform
func (tl TargetList) GroupByPlatform() map[string][]Target <span class="cov0" title="0">{
        groups := make(map[string][]Target)
        for _, target := range tl </span><span class="cov0" title="0">{
                platform := target.Platform
                if platform == PlatformAuto </span><span class="cov0" title="0">{
                        // Skip auto-detect targets, they should be resolved elsewhere
                        continue</span>
                }
                <span class="cov0" title="0">groups[platform] = append(groups[platform], target)</span>
        }
        <span class="cov0" title="0">return groups</span>
}

// Validate validates all targets in the list
func (tl TargetList) Validate() error <span class="cov0" title="0">{
        if len(tl) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("target list cannot be empty")
        }</span>

        <span class="cov0" title="0">for i, target := range tl </span><span class="cov0" title="0">{
                if err := target.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("target %d validation failed: %w", i, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Filter returns targets that match the given predicate
func (tl TargetList) Filter(predicate func(Target) bool) TargetList <span class="cov0" title="0">{
        filtered := make(TargetList, 0)
        for _, target := range tl </span><span class="cov0" title="0">{
                if predicate(target) </span><span class="cov0" title="0">{
                        filtered = append(filtered, target)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// GetByPlatform returns all targets for a specific platform
func (tl TargetList) GetByPlatform(platform string) TargetList <span class="cov0" title="0">{
        return tl.Filter(func(t Target) bool </span><span class="cov0" title="0">{
                return t.Platform == platform
        }</span>)
}

// GetByType returns all targets of a specific type
func (tl TargetList) GetByType(targetType string) TargetList <span class="cov0" title="0">{
        return tl.Filter(func(t Target) bool </span><span class="cov0" title="0">{
                return t.Type == targetType
        }</span>)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
