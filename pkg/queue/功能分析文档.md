# NotifyHub 队列系统设计文档

## 一、系统概述

NotifyHub 队列系统是专为**统一通知系统**设计的轻量级异步消息处理组件。它专注于通知场景的核心需求，提供简洁高效的异步消息处理能力。

### 1.1 设计原则

1. **简洁性优先** - 专注通知场景，避免过度工程化
2. **性能导向** - 高效的消息处理和低延迟
3. **易于使用** - 直观的API设计，快速上手
4. **可靠性** - 保证消息不丢失，支持故障恢复
5. **可扩展** - 支持水平扩展和不同存储后端

### 1.2 核心功能

- ✅ **异步消息处理** - 解耦通知发送，提升系统响应性
- ✅ **优先级队列** - 支持紧急通知优先处理
- ✅ **延迟调度** - 支持定时通知发送
- ✅ **重试机制** - 自动重试失败的通知
- ✅ **死信队列** - 处理彻底失败的消息
- ✅ **多种后端** - 内存队列、Redis队列
- ✅ **监控指标** - 队列状态和性能监控
- ✅ **工作池管理** - 自动扩缩容的工作协程

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────┐
│                NotifyHub Client                 │
└─────────────────┬───────────────────────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│            Async Hub (异步处理层)                │
├─────────────────────────────────────────────────┤
│         Notification Queue (通知队列)           │
├──────┬──────┬──────────────────────────────────┤
│Memory│Redis │         工作池管理                │
│ 队列  │ 队列 │     (Worker Pool)               │
├──────┴──────┴──────────────────────────────────┤
│        重试机制 & 死信队列处理                   │
├─────────────────────────────────────────────────┤
│              监控 & 指标收集                    │
└─────────────────────────────────────────────────┘
```

### 2.2 核心组件

#### 2.2.1 队列接口层

```go
// 基础队列接口
type Queue interface {
    Enqueue(ctx context.Context, msg *Message) error
    EnqueueBatch(ctx context.Context, msgs []*Message) error
    Dequeue(ctx context.Context) (*Message, error)
    DequeueBatch(ctx context.Context, count int) ([]*Message, error)
    Size() int
    IsEmpty() bool
    Close() error
}

// 延迟队列支持
type DelayQueue interface {
    Queue
    EnqueueDelayed(ctx context.Context, msg *Message, delay time.Duration) error
    EnqueueScheduled(ctx context.Context, msg *Message, scheduledAt time.Time) error
}

// 重试队列支持
type RetryQueue interface {
    Queue
    Retry(ctx context.Context, msg *Message) error
    MoveToDeadLetter(ctx context.Context, msg *Message) error
    GetDeadLetterQueue() Queue
}
```

#### 2.2.2 消息结构

```go
type Message struct {
    ID          string                 // 消息唯一标识
    Payload     interface{}            // 通知消息内容
    Priority    Priority               // 优先级 (低/普通/高/紧急)
    Metadata    map[string]interface{} // 元数据
    Timestamp   time.Time              // 创建时间
    RetryCount  int                    // 重试次数
    MaxRetries  int                    // 最大重试次数
    ScheduledAt *time.Time             // 调度时间
    CreatedAt   time.Time              // 入队时间
    UpdatedAt   time.Time              // 更新时间
}

type Priority int
const (
    PriorityLow    Priority = 0  // 低优先级 (批量通知)
    PriorityNormal Priority = 1  // 普通优先级 (常规通知)
    PriorityHigh   Priority = 2  // 高优先级 (重要通知)
    PriorityUrgent Priority = 3  // 紧急优先级 (告警通知)
)
```

## 三、队列实现

### 3.1 内存队列 (MemoryQueue)

**适用场景：**

- 开发环境和测试环境
- 小规模部署
- 对消息持久化要求不高的场景

**核心特性：**

- 基于 Go channel 实现，性能优异
- 支持容量限制，防止内存溢出
- 优先级堆排序，确保高优先级消息优先处理
- 延迟消息基于最小堆实现，时间复杂度 O(log n)
- 支持批量操作，提高吞吐量

**实现架构：**

```go
type memoryQueue struct {
    messages        chan *Message      // 普通消息通道
    priorityHeap    *priorityHeap      // 优先级消息堆
    delayedMessages *delayHeap         // 延迟消息堆
    capacity        int                // 队列容量
    stats           *QueueStats        // 统计信息
    mutex           sync.RWMutex       // 并发控制
}
```

**性能指标：**

- 入队延迟：< 1ms (普通消息)，< 5ms (优先级消息)
- 出队延迟：< 1ms
- 吞吐量：> 10,000 ops/sec
- 内存占用：可预测，由容量限制控制

### 3.2 Redis队列 (RedisQueue)

**适用场景：**

- 生产环境
- 需要消息持久化
- 多实例部署
- 高可用要求

**核心特性：**

- 基于 Redis List 和 Sorted Set 实现
- 消息持久化，应用重启不丢失
- 支持分布式部署，多个实例共享队列
- 使用 Lua 脚本保证操作原子性
- 支持 Redis 集群模式

**数据结构设计：**

```
主队列:     LIST (notifyhub:queue:main)
优先队列:   LIST (notifyhub:queue:priority)
延迟队列:   ZSET (notifyhub:queue:delayed) - Score为时间戳
处理队列:   LIST (notifyhub:queue:processing) - 可靠性保证
死信队列:   LIST (notifyhub:queue:dlq)
```

**性能优化：**

- 使用 Redis Pipeline 进行批量操作
- 连接池复用，减少连接开销
- Lua 脚本原子化复杂操作
- 定期清理过期的处理中消息

## 四、重试与容错机制

### 4.1 重试策略

**指数退避算法**：

```go
type RetryPolicy struct {
    MaxRetries      int           // 最大重试次数 (建议: 3-5次)
    InitialInterval time.Duration // 初始重试间隔 (建议: 1秒)
    MaxInterval     time.Duration // 最大重试间隔 (建议: 30秒)
    Multiplier      float64       // 退避乘数 (建议: 2.0)
    MaxElapsedTime  time.Duration // 最大重试时间窗口 (建议: 5分钟)
}
```

**重试触发条件**：

- 网络连接失败
- 平台API临时不可用 (5xx错误)
- 速率限制 (429错误)
- 临时性认证失败

**不重试条件**：

- 消息格式错误 (400错误)
- 认证凭据无效 (401/403错误)
- 目标不存在 (404错误)
- 消息内容违规

### 4.2 死信队列处理

**进入死信队列的条件**：

1. 超过最大重试次数
2. 消息处理超时
3. 消息格式无法解析
4. 不可恢复的业务错误

**死信队列消息结构**：

```go
type DeadLetterMessage struct {
    *Message                    // 原始消息
    FailureReason  string       // 失败原因
    FailureTime    time.Time    // 失败时间
    LastError      error        // 最后一次错误
    RetryHistory   []RetryAttempt // 重试历史
}

type RetryAttempt struct {
    Attempt   int       // 第几次重试
    Error     error     // 错误信息
    Timestamp time.Time // 重试时间
}
```

**死信队列处理策略**：

- 定期告警通知管理员
- 支持手动重新入队
- 自动过期清理 (建议7天)
- 错误分析和统计

## 五、工作池管理

### 5.1 自动扩缩容策略

```go
type WorkerPool struct {
    minWorkers  int  // 最小工作协程数
    maxWorkers  int  // 最大工作协程数
    scalePolicy ScalePolicy // 扩缩容策略
}

type ScalePolicy struct {
    ScaleUpThreshold   int           // 扩容阈值 (队列深度)
    ScaleDownThreshold int           // 缩容阈值 (队列深度)
    ScaleUpStep        int           // 扩容步长
    ScaleDownStep      int           // 缩容步长
    ScaleInterval      time.Duration // 扩缩容检查间隔
}
```

**扩缩容规则**：

```
队列深度    | 工作协程数    | 说明
----------|-------------|------------------
0-10      | 最小值       | 基础负载
11-50     | 最小值+2     | 轻度负载
51-100    | (最小+最大)/2 | 中等负载
100+      | 最大值       | 高负载
```

### 5.2 工作协程生命周期

1. **启动阶段** - 启动最小数量的工作协程
2. **运行阶段** - 持续从队列获取消息并处理
3. **监控阶段** - 定期检查队列深度，调整协程数量
4. **关闭阶段** - 优雅停止，等待处理中的消息完成

## 六、监控与可观测性

### 6.1 核心指标

**队列指标**：

```go
type QueueMetrics struct {
    Size            int64         // 当前队列大小
    EnqueuedCount   int64         // 总入队数
    DequeuedCount   int64         // 总出队数
    RetryCount      int64         // 总重试次数
    DeadLetterCount int64         // 死信队列大小
    AverageLatency  time.Duration // 平均处理延迟
    ThroughputQPS   float64       // 处理速率 (QPS)
}
```

**工作池指标**：

```go
type WorkerMetrics struct {
    ActiveWorkers   int           // 活跃工作协程数
    IdleWorkers     int           // 空闲工作协程数
    ProcessedCount  int64         // 总处理消息数
    ErrorCount      int64         // 总错误数
    AverageTime     time.Duration // 平均处理时间
}
```

### 6.2 健康检查

**健康检查端点**：

```go
type HealthStatus struct {
    Status      string                 // "healthy" | "degraded" | "unhealthy"
    QueueSize   int                   // 队列大小
    Workers     int                   // 工作协程数
    LastProcess time.Time             // 最后处理时间
    Errors      []HealthError         // 错误列表
    Uptime      time.Duration         // 运行时间
}
```

**健康状态判断**：

- **健康** - 队列正常处理，无积压，错误率 < 5%
- **降级** - 队列有积压或错误率 5%-20%
- **不健康** - 队列严重积压，错误率 > 20%，或服务不可用

## 七、使用示例

### 7.1 基础使用

```go
// 创建异步Hub
asyncHub, err := notifyhub.NewAsyncHubWithOptions(
    baseHub,
    logger,
    notifyhub.WithMemoryQueue(1000, 4),
    notifyhub.WithQueueRetry(3, 1*time.Second),
    notifyhub.WithDeadLetterQueue(true),
)

// 发送异步通知
message := notifyhub.NewMessage("系统告警", "CPU使用率超过90%").
    WithPriority(notifyhub.PriorityHigh).
    AddEmail("ops@example.com").
    Build()

receipt, err := asyncHub.SendQueued(ctx, message)
```

### 7.2 延迟发送

```go
// 5分钟后发送提醒
scheduledTime := time.Now().Add(5 * time.Minute)
reminder := notifyhub.NewMessage("会议提醒", "团队例会将在10分钟后开始").
    WithScheduledTime(&scheduledTime).
    AddTarget(notifyhub.Target{
        Type:     notifyhub.TargetTypeChannel,
        Platform: notifyhub.PlatformFeishu,
        Value:    "team-channel",
    }).
    Build()

asyncHub.SendQueued(ctx, reminder)
```

### 7.3 批量处理

```go
// 批量发送每日报告
reports := []notifyhub.Message{
    *notifyhub.NewMessage("销售日报", "今日销售额：￥12,345").
        AddEmail("sales@example.com").Build(),
    *notifyhub.NewMessage("技术周报", "本周完成功能：3项").
        AddEmail("tech@example.com").Build(),
}

for _, report := range reports {
    asyncHub.SendQueued(ctx, &report)
}
```

### 7.4 监控队列状态

```go
// 获取队列统计信息
stats := asyncHub.GetQueueStats()
fmt.Printf("队列大小: %d\n", stats["queue_size"])
fmt.Printf("处理状态: %v\n", stats["processing"])

if workers, ok := stats["workers"].(map[string]interface{}); ok {
    fmt.Printf("工作协程数: %v\n", workers["worker_count"])
    fmt.Printf("已处理消息: %v\n", workers["processed_count"])
}
```

## 八、配置选项

### 8.1 内存队列配置

```go
// 开发环境配置
config := notifyhub.WithMemoryQueue(
    1000,  // 容量
    4,     // 工作协程数
)

// 高负载配置
config := notifyhub.WithMemoryQueue(
    5000,  // 更大容量
    8,     // 更多工作协程
)
```

### 8.2 Redis队列配置

```go
// 生产环境配置
config := notifyhub.WithRedisQueue(
    "redis://localhost:6379", // Redis地址
    10000, // 容量
    8,     // 工作协程数
)

// 高可用配置
config := notifyhub.WithRedisQueue(
    "redis://redis-cluster:6379",
    50000, // 大容量
    16,    // 更多工作协程
)
```

### 8.3 重试策略配置

```go
// 标准重试策略
retryConfig := notifyhub.WithQueueRetry(
    3,               // 最大重试3次
    1*time.Second,   // 初始间隔1秒
)

// 激进重试策略 (重要通知)
retryConfig := notifyhub.WithQueueRetry(
    5,               // 最大重试5次
    500*time.Millisecond, // 初始间隔500ms
)

// 保守重试策略 (批量通知)
retryConfig := notifyhub.WithQueueRetry(
    2,               // 最大重试2次
    2*time.Second,   // 初始间隔2秒
)
```

## 九、性能基准

### 9.1 内存队列性能

```
操作类型          | 延迟 (p99) | 吞吐量 (ops/sec)
-----------------|-----------|------------------
单条消息入队      | < 1ms     | 15,000
批量消息入队(100) | < 10ms    | 50,000
单条消息出队      | < 1ms     | 12,000
批量消息出队(10)  | < 5ms     | 30,000
```

### 9.2 Redis队列性能

```
操作类型          | 延迟 (p99) | 吞吐量 (ops/sec)
-----------------|-----------|------------------
单条消息入队      | < 5ms     | 8,000
批量消息入队(100) | < 50ms    | 25,000
单条消息出队      | < 5ms     | 7,000
批量消息出队(10)  | < 20ms    | 15,000
```

### 9.3 系统资源消耗

**内存队列**：

- 内存使用：~50MB (1000条消息队列)
- CPU使用：~2% (4个工作协程)
- 网络带宽：忽略不计

**Redis队列**：

- 内存使用：~20MB (应用本地)
- CPU使用：~3% (8个工作协程)
- 网络带宽：~1MB/s (高负载时)

## 十、最佳实践

### 10.1 队列容量设置

- **开发环境**：500-1000 (快速测试)
- **测试环境**：1000-2000 (模拟负载)
- **生产环境**：5000-10000 (高可用)
- **高负载生产**：10000+ (极限性能)

### 10.2 工作协程数量

```
服务器规格    | 推荐工作协程数 | 说明
-------------|---------------|------------------------
1C2G         | 2-4          | 小型应用
2C4G         | 4-8          | 中型应用
4C8G         | 8-16         | 大型应用
8C16G+       | 16-32        | 高负载应用
```

### 10.3 监控告警规则

**队列深度告警**：

- 告警：队列深度 > 容量的70%
- 严重：队列深度 > 容量的90%

**错误率告警**：

- 告警：错误率 > 5%
- 严重：错误率 > 20%

**延迟告警**：

- 告警：平均延迟 > 5秒
- 严重：平均延迟 > 30秒

### 10.4 故障处理

**队列积压处理**：

1. 临时增加工作协程数量
2. 检查下游服务是否正常
3. 考虑降级处理，跳过非关键通知

**死信队列处理**：

1. 每日检查死信队列大小
2. 分析失败原因，修复根本问题
3. 手动重新处理可修复的消息
4. 定期清理无法修复的历史消息

**服务恢复**：

1. Redis队列支持应用重启后自动恢复
2. 内存队列重启会丢失数据，建议生产环境使用Redis
3. 实现优雅关闭，确保处理中的消息完成

## 十一、后续规划

### 11.1 短期计划 (1-3个月)

1. **性能优化**
   - 优化批量操作性能
   - 减少内存分配和GC压力
   - 改进Redis连接池管理

2. **功能增强**
   - 支持消息压缩 (降低内存/网络占用)
   - 增加更多监控指标
   - 改进死信队列管理UI

### 11.2 中期计划 (3-6个月)

1. **高可用增强**
   - 支持Redis Cluster
   - 实现队列分片
   - 添加故障自动转移

2. **用户体验改进**
   - 提供队列管理Web界面
   - 增加消息追踪功能
   - 支持消息搜索和过滤

### 11.3 长期计划 (6-12个月)

1. **企业级特性** (按需)
   - 消息加密支持
   - 审计日志记录
   - 多租户隔离

2. **生态集成**
   - Prometheus指标导出
   - Grafana监控面板
   - Kubernetes Operator

---

## 总结

NotifyHub队列系统采用简洁实用的设计理念，专注于通知系统的核心需求。通过合理的架构设计和性能优化，为通知发送提供了可靠、高效的异步处理能力。

**核心优势**：

- 🎯 **专注通知场景** - 避免过度工程化
- ⚡ **性能优异** - 高吞吐量，低延迟
- 🔧 **易于使用** - 简洁的API，快速集成
- 🛡️ **可靠性强** - 完善的重试和容错机制
- 📊 **可观测** - 全面的监控和指标支持

该系统为NotifyHub提供了坚实的异步处理基础，满足从小型应用到大规模部署的各种需求。
