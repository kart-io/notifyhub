// Package tests provides async processing validation tests for NotifyHub
package tests

import (
	"context"
	"fmt"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/kart-io/notifyhub/pkg/notifyhub"
	"github.com/kart-io/notifyhub/pkg/notifyhub/async"
	"github.com/kart-io/notifyhub/pkg/notifyhub/config"
	"github.com/kart-io/notifyhub/pkg/notifyhub/message"
	"github.com/kart-io/notifyhub/pkg/notifyhub/target"
)

// TestAsyncProcessingReality validates that SendAsync uses real queues not synchronous calls
func TestAsyncProcessingReality(t *testing.T) {
	t.Run("TrueAsyncExecution", func(t *testing.T) {
		// Create hub with async enabled
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  100 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			notifyhub.WithEmail(emailConfig.SMTPHost, emailConfig.SMTPPort, emailConfig.SMTPFrom),
		)
		if err != nil {
			t.Fatalf("Failed to create async hub: %v", err)
		}
		defer hub.Close()

		// Verify async capability exists (SendAsync method should be available)
		// This is validated at compile time by the method call below

		// Create test message
		msg := &message.Message{
			ID:      "async-test-1",
			Title:   "Async Test Message",
			Body:    "Testing async processing",
			Format:  "text",
			Targets: []target.Target{
				{Type: "email", Value: "user@test.com"},
			},
		}

		// Measure execution time of SendAsync call
		startTime := time.Now()
		resultChan, err := hub.SendAsync(context.Background(), msg)
		asyncCallDuration := time.Since(startTime)

		if err != nil {
			t.Fatalf("SendAsync failed: %v", err)
		}

		// SendAsync should return immediately (< 10ms), proving it's truly async
		if asyncCallDuration > 10*time.Millisecond {
			t.Errorf("SendAsync took too long (%v), likely not truly async", asyncCallDuration)
		}

		// Channel should be returned immediately
		if resultChan == nil {
			t.Fatal("Async result channel should not be nil")
		}

		// Channel should not have result immediately (proving it's truly async)
		select {
		case <-resultChan:
			t.Log("Result received immediately (may be expected in test environment)")
		case <-time.After(1 * time.Millisecond):
			t.Log("No immediate result, confirming async behavior")
		}

		t.Logf("SendAsync completed in %v (expected < 10ms)", asyncCallDuration)
	})

	t.Run("QueueBasedProcessing", func(t *testing.T) {
		// Create hub with very small worker count to test queuing
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  50 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(10, 1), // Single worker to test queuing
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		// Send multiple messages rapidly
		handles := make([]async.AsyncHandle, 5)
		for i := 0; i < 5; i++ {
			msg := &message.Message{
				ID:      fmt.Sprintf("queue-test-%d", i),
				Title:   "Queue Test Message",
				Body:    "Testing queue processing",
				Format:  "text",
				Targets: []target.Target{
					{Type: "email", Value: "user@test.com"},
				},
			}

			handle, err := hub.SendAsync(context.Background(), msg)
			if err != nil {
				t.Fatalf("SendAsync %d failed: %v", i, err)
			}
			handles[i] = handle
		}

		// Verify messages are queued (not all immediately processing)
		processingCount := 0
		pendingCount := 0
		for _, handle := range handles {
			if handle.IsDone() {
				// Some might complete immediately in test environment
			} else {
				progress := handle.GetProgress()
				if progress != nil && progress.Processed > 0 {
					processingCount++
				} else {
					pendingCount++
				}
			}
		}

		// With single worker, some messages should be queued
		if pendingCount == 0 && len(handles) > 1 {
			t.Log("Warning: All messages processed immediately, queue behavior may not be evident in test")
		}

		t.Logf("Queued messages - Processing: %d, Pending: %d", processingCount, pendingCount)
	})
}

// TestAsyncOperationStates validates async operation state management
func TestAsyncOperationStates(t *testing.T) {
	t.Run("StateTransitions", func(t *testing.T) {
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  100 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(50, 2),
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		msg := &message.Message{
			ID:      "state-test-1",
			Title:   "State Test Message",
			Body:    "Testing state transitions",
			Format:  "text",
			Targets: []target.Target{
				{Type: "email", Value: "user@test.com"},
			},
		}

		handle, err := hub.SendAsync(context.Background(), msg)
		if err != nil {
			t.Fatalf("SendAsync failed: %v", err)
		}

		// Track state transitions
		states := make([]string, 0)
		stateChanges := 0

		// Monitor state for up to 5 seconds
		timeout := time.After(5 * time.Second)
		ticker := time.NewTicker(10 * time.Millisecond)
		defer ticker.Stop()

		lastState := ""
	stateLoop:
		for {
			select {
			case <-timeout:
				break stateLoop
			case <-ticker.C:
				currentState := getHandleState(handle)
				if currentState != lastState {
					states = append(states, currentState)
					lastState = currentState
					stateChanges++

					if handle.IsDone() {
						break stateLoop
					}
				}
			}
		}

		// Verify state transitions occurred
		if stateChanges < 2 {
			t.Errorf("Expected at least 2 state changes, got %d", stateChanges)
		}

		// Verify final state
		if !handle.IsDone() {
			t.Error("Handle should be done after processing")
		}

		t.Logf("State transitions: %v", states)
	})

	t.Run("ProgressTracking", func(t *testing.T) {
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  50 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(50, 1), // Single worker for predictable progress
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		// Message with multiple targets for progress tracking
		msg := &message.Message{
			ID:     "progress-test-1",
			Title:  "Progress Test Message",
			Body:   "Testing progress tracking",
			Format: "text",
			Targets: []target.Target{
				{Type: "email", Value: "user1@test.com"},
				{Type: "email", Value: "user2@test.com"},
				{Type: "email", Value: "user3@test.com"},
			},
		}

		handle, err := hub.SendAsync(context.Background(), msg)
		if err != nil {
			t.Fatalf("SendAsync failed: %v", err)
		}

		// Monitor progress
		progressUpdates := make([]*async.Progress, 0)
		timeout := time.After(3 * time.Second)
		ticker := time.NewTicker(20 * time.Millisecond)
		defer ticker.Stop()

	progressLoop:
		for {
			select {
			case <-timeout:
				break progressLoop
			case <-ticker.C:
				progress := handle.GetProgress()
				if progress != nil {
					progressUpdates = append(progressUpdates, progress)
				}
				if handle.IsDone() {
					break progressLoop
				}
			}
		}

		// Verify progress tracking
		if len(progressUpdates) == 0 {
			t.Error("No progress updates received")
		} else {
			finalProgress := progressUpdates[len(progressUpdates)-1]
			if finalProgress.Total != 3 {
				t.Errorf("Expected 3 total targets, got %d", finalProgress.Total)
			}

			t.Logf("Progress updates: %d, Final: %d/%d processed",
				len(progressUpdates), finalProgress.Processed, finalProgress.Total)
		}
	})
}

// TestAsyncCallbacks validates callback functionality
func TestAsyncCallbacks(t *testing.T) {
	t.Run("CallbackExecution", func(t *testing.T) {
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  50 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(50, 2),
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		// Callback tracking
		var callbackMutex sync.Mutex
		callbacksReceived := make([]string, 0)
		progressCallbacks := int32(0)
		resultCallbacks := int32(0)
		errorCallbacks := int32(0)

		// Create async options with callbacks
		opts := []async.AsyncOption{
			async.WithOnProgress(func(progress *async.Progress) {
				atomic.AddInt32(&progressCallbacks, 1)
				callbackMutex.Lock()
				callbacksReceived = append(callbacksReceived, "progress")
				callbackMutex.Unlock()
			}),
			async.WithOnResult(func(result interface{}) {
				atomic.AddInt32(&resultCallbacks, 1)
				callbackMutex.Lock()
				callbacksReceived = append(callbacksReceived, "result")
				callbackMutex.Unlock()
			}),
			async.WithOnError(func(err error) {
				atomic.AddInt32(&errorCallbacks, 1)
				callbackMutex.Lock()
				callbacksReceived = append(callbacksReceived, "error")
				callbackMutex.Unlock()
			}),
		}

		msg := &message.Message{
			ID:     "callback-test-1",
			Title:  "Callback Test Message",
			Body:   "Testing callback functionality",
			Format: "text",
			Targets: []target.Target{
				{Type: "email", Value: "user1@test.com"},
				{Type: "email", Value: "user2@test.com"},
			},
		}

		handle, err := hub.SendAsync(context.Background(), msg, opts...)
		if err != nil {
			t.Fatalf("SendAsync with callbacks failed: %v", err)
		}

		// Wait for completion with timeout
		done := make(chan bool)
		go func() {
			for !handle.IsDone() {
				time.Sleep(10 * time.Millisecond)
			}
			done <- true
		}()

		select {
		case <-done:
			// Operation completed
		case <-time.After(5 * time.Second):
			t.Error("Operation timed out")
		}

		// Verify callbacks were triggered
		progressCount := atomic.LoadInt32(&progressCallbacks)
		resultCount := atomic.LoadInt32(&resultCallbacks)
		errorCount := atomic.LoadInt32(&errorCallbacks)

		if progressCount == 0 {
			t.Error("No progress callbacks received")
		}

		if resultCount == 0 && errorCount == 0 {
			t.Error("No result or error callbacks received")
		}

		callbackMutex.Lock()
		totalCallbacks := len(callbacksReceived)
		callbackMutex.Unlock()

		t.Logf("Callbacks received - Progress: %d, Result: %d, Error: %d, Total: %d",
			progressCount, resultCount, errorCount, totalCallbacks)
	})
}

// TestAsyncCancellation validates async operation cancellation
func TestAsyncCancellation(t *testing.T) {
	t.Run("ContextCancellation", func(t *testing.T) {
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  1 * time.Second, // Longer timeout to allow cancellation
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(50, 1), // Single worker
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		// Create cancellable context
		ctx, cancel := context.WithCancel(context.Background())

		msg := &message.Message{
			ID:     "cancel-test-1",
			Title:  "Cancellation Test Message",
			Body:   "Testing cancellation",
			Format: "text",
			Targets: []target.Target{
				{Type: "email", Value: "user1@test.com"},
				{Type: "email", Value: "user2@test.com"},
				{Type: "email", Value: "user3@test.com"},
			},
		}

		handle, err := hub.SendAsync(ctx, msg)
		if err != nil {
			t.Fatalf("SendAsync failed: %v", err)
		}

		// Cancel after short delay
		go func() {
			time.Sleep(100 * time.Millisecond)
			cancel()
		}()

		// Wait for cancellation to take effect
		time.Sleep(200 * time.Millisecond)

		// Verify operation was cancelled
		if !handle.IsCancelled() && !handle.IsDone() {
			t.Log("Warning: Operation may not have been cancelled (test timing dependent)")
		}

		t.Logf("Handle state after cancellation: Done=%v, Cancelled=%v",
			handle.IsDone(), handle.IsCancelled())
	})
}

// TestAsyncResourceCleanup validates proper resource cleanup
func TestAsyncResourceCleanup(t *testing.T) {
	t.Run("HandleCleanup", func(t *testing.T) {
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  50 * time.Millisecond,
		}

		hub, err := notifyhub.New(
			config.WithEmail(emailConfig),
			config.WithAsync(20, 2),
		)
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}

		// Create multiple async operations
		handles := make([]async.AsyncHandle, 10)
		for i := 0; i < 10; i++ {
			msg := &message.Message{
				ID:     fmt.Sprintf("cleanup-test-%d", i),
				Title:  "Cleanup Test Message",
				Body:   "Testing cleanup",
				Format: "text",
				Targets: []target.Target{
					{Type: "email", Value: "user@test.com"},
				},
			}

			handle, err := hub.SendAsync(context.Background(), msg)
			if err != nil {
				t.Fatalf("SendAsync %d failed: %v", i, err)
			}
			handles[i] = handle
		}

		// Wait for completion
		for _, handle := range handles {
			for !handle.IsDone() {
				time.Sleep(10 * time.Millisecond)
			}
		}

		// Close hub (should cleanup resources)
		err = hub.Close()
		if err != nil {
			t.Errorf("Hub close failed: %v", err)
		}

		// Verify handles are still accessible but operations are done
		for i, handle := range handles {
			if !handle.IsDone() {
				t.Errorf("Handle %d should be done after hub close", i)
			}
		}

		t.Log("Resource cleanup completed successfully")
	})
}

// Helper functions

func getHandleState(handle async.AsyncHandle) string {
	if handle.IsCancelled() {
		return "cancelled"
	}
	if handle.IsDone() {
		return "done"
	}
	progress := handle.GetProgress()
	if progress != nil && progress.Processed > 0 {
		return "processing"
	}
	return "pending"
}