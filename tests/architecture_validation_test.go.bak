// Package tests provides architecture validation tests for NotifyHub refactoring
package tests

import (
	"context"
	"go/ast"
	"go/parser"
	"go/token"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/kart-io/notifyhub/pkg/notifyhub"
	"github.com/kart-io/notifyhub/pkg/notifyhub/config"
	"github.com/kart-io/notifyhub/pkg/notifyhub/message"
	"github.com/kart-io/notifyhub/pkg/notifyhub/platform"
	"github.com/kart-io/notifyhub/pkg/notifyhub/target"
)

// TestDualInterfaceElimination validates that duplicate interfaces are eliminated
func TestDualInterfaceElimination(t *testing.T) {
	t.Run("NoInternalPlatformInterface", func(t *testing.T) {
		// Verify internal/platform interface no longer exists
		_, err := parser.ParseDir(token.NewFileSet(), "pkg/internal/platform", nil, parser.ParseComments)
		if err == nil {
			t.Error("internal/platform package still exists - dual interfaces not eliminated")
		}
	})

	t.Run("SinglePlatformInterface", func(t *testing.T) {
		// Verify only one Platform interface exists
		interfaceCount := countPlatformInterfaces(t)
		if interfaceCount != 1 {
			t.Errorf("Expected 1 Platform interface, found %d", interfaceCount)
		}
	})

	t.Run("NoExternalSenderInterface", func(t *testing.T) {
		// Verify ExternalSender interface is removed
		hasExternalSender := checkForInterface(t, "ExternalSender")
		if hasExternalSender {
			t.Error("ExternalSender interface still exists - dual interfaces not eliminated")
		}
	})
}

// TestCallChainReduction validates call chain reduction from 6 to 3 layers
func TestCallChainReduction(t *testing.T) {
	t.Run("DirectClientToPlatformPath", func(t *testing.T) {
		// Create a test hub
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  10 * time.Second,
		}

		hub, err := notifyhub.New(notifyhub.WithEmail(emailConfig.SMTPHost, emailConfig.SMTPPort, emailConfig.SMTPFrom))
		if err != nil {
			t.Fatalf("Failed to create hub: %v", err)
		}
		defer hub.Close()

		// Create a test message
		msg := &message.Message{
			ID:      "test-msg-1",
			Title:   "Test Message",
			Body:    "Test Body",
			Format:  "text",
			Targets: []target.Target{
				{Type: "email", Value: "user@test.com"},
			},
		}

		// Trace the call path by examining stack traces
		callStack := captureCallStack(t, func() {
			ctx := context.Background()
			_, _ = hub.Send(ctx, msg)
		})

		// Verify call chain is simplified (Client → Dispatcher → Platform)
		expectedLayers := []string{
			"Send",        // Client layer
			"Dispatch",    // Dispatcher layer
			"Send",        // Platform layer
		}

		validateCallChain(t, callStack, expectedLayers)
	})
}

// TestTypeAssertionElimination validates compile-time type checking
func TestTypeAssertionElimination(t *testing.T) {
	t.Run("NoRuntimeTypeAssertions", func(t *testing.T) {
		// Scan codebase for type assertions in critical paths
		typeAssertionCount := countTypeAssertions(t)

		// Allow some type assertions for interface conversions, but significantly reduced
		maxAllowedAssertions := 10 // Down from previous ~50+
		if typeAssertionCount > maxAllowedAssertions {
			t.Errorf("Too many type assertions found: %d (max allowed: %d). Strong typing not fully implemented",
				typeAssertionCount, maxAllowedAssertions)
		}
	})

	t.Run("StrongTypedConfigurations", func(t *testing.T) {
		// Verify all platform configurations use strong types
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  10 * time.Second,
		}

		// This should compile without any type assertions
		_, err := notifyhub.New(notifyhub.WithEmail(emailConfig.SMTPHost, emailConfig.SMTPPort, emailConfig.SMTPFrom))
		if err != nil {
			t.Fatalf("Strong-typed configuration failed: %v", err)
		}

		// Verify configuration types at compile time
		configType := reflect.TypeOf(emailConfig)
		if configType.Kind() != reflect.Ptr || configType.Elem().Kind() != reflect.Struct {
			t.Error("Email configuration is not a strong-typed struct")
		}
	})
}

// TestMessageTransformationReduction validates reduced transformation layers
func TestMessageTransformationReduction(t *testing.T) {
	t.Run("SingleTransformationLayer", func(t *testing.T) {
		// Create test message
		msg := &message.Message{
			ID:     "test-msg-1",
			Title:  "Test Message",
			Body:   "Test Body",
			Format: "text",
			Targets: []target.Target{
				{Type: "email", Value: "user@test.com"},
			},
		}

		// Message should maintain its structure throughout the pipeline
		originalMsgType := reflect.TypeOf(msg)

		// Verify the message type remains consistent (no multiple transformations)
		if originalMsgType.String() != "*message.Message" {
			t.Error("Message type not consistent - multiple transformation layers detected")
		}

		// Verify message content is not transformed multiple times
		if msg.Body != "Test Body" {
			t.Error("Message body was transformed unexpectedly")
		}
	})
}

// Helper functions

// countPlatformInterfaces counts Platform interface definitions in codebase
func countPlatformInterfaces(t *testing.T) int {
	count := 0

	// Parse platform package
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, "pkg/notifyhub/platform", nil, parser.ParseComments)
	if err != nil {
		t.Logf("Could not parse platform package: %v", err)
		return 0
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if interfaceType, ok := typeSpec.Type.(*ast.InterfaceType); ok {
						if strings.Contains(typeSpec.Name.Name, "Platform") {
							_ = interfaceType // Verify it's actually an interface
							count++
						}
					}
				}
				return true
			})
		}
	}

	return count
}

// checkForInterface checks if a specific interface exists in the codebase
func checkForInterface(t *testing.T, interfaceName string) bool {
	// Search in common packages
	packages := []string{
		"pkg/notifyhub/platform",
		"pkg/internal",
		"pkg/platforms",
	}

	for _, pkg := range packages {
		if hasInterfaceInPackage(pkg, interfaceName) {
			return true
		}
	}

	return false
}

// hasInterfaceInPackage checks if an interface exists in a specific package
func hasInterfaceInPackage(packagePath, interfaceName string) bool {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
	if err != nil {
		return false
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			found := false
			ast.Inspect(file, func(n ast.Node) bool {
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if interfaceType, ok := typeSpec.Type.(*ast.InterfaceType); ok {
						if typeSpec.Name.Name == interfaceName {
							_ = interfaceType
							found = true
							return false
						}
					}
				}
				return true
			})
			if found {
				return true
			}
		}
	}

	return false
}

// captureCallStack captures call stack during function execution
func captureCallStack(t *testing.T, fn func()) []string {
	var stack []string

	// Execute function and capture runtime stack
	fn()

	// Get program counters for stack trace
	pcs := make([]uintptr, 50)
	n := runtime.Callers(1, pcs)
	frames := runtime.CallersFrames(pcs[:n])

	for {
		frame, more := frames.Next()
		if strings.Contains(frame.File, "notifyhub") {
			funcName := filepath.Base(frame.Function)
			stack = append(stack, funcName)
		}
		if !more {
			break
		}
	}

	return stack
}

// validateCallChain validates that call chain matches expected layers
func validateCallChain(t *testing.T, actualStack []string, expectedLayers []string) {
	// Filter stack to relevant layers
	relevantCalls := make([]string, 0)
	for _, call := range actualStack {
		for _, expected := range expectedLayers {
			if strings.Contains(call, expected) {
				relevantCalls = append(relevantCalls, call)
			}
		}
	}

	if len(relevantCalls) > len(expectedLayers)*2 { // Allow some tolerance
		t.Errorf("Call chain too complex: found %d layers, expected around %d",
			len(relevantCalls), len(expectedLayers))
		t.Logf("Actual call chain: %v", relevantCalls)
	}
}

// countTypeAssertions counts type assertion occurrences in critical paths
func countTypeAssertions(t *testing.T) int {
	count := 0

	// Critical packages to check
	packages := []string{
		"pkg/notifyhub/client",
		"pkg/notifyhub/core",
		"pkg/platforms",
		"pkg/notifyhub/config",
	}

	for _, pkg := range packages {
		count += countTypeAssertionsInPackage(pkg)
	}

	return count
}

// countTypeAssertionsInPackage counts type assertions in a specific package
func countTypeAssertionsInPackage(packagePath string) int {
	count := 0

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
	if err != nil {
		return 0
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Look for type assertions: x.(Type)
				if typeAssert, ok := n.(*ast.TypeAssertExpr); ok {
					_ = typeAssert
					count++
				}
				return true
			})
		}
	}

	return count
}

// TestArchitectureIntegrity validates overall architecture integrity
func TestArchitectureIntegrity(t *testing.T) {
	t.Run("UnifiedPlatformInterface", func(t *testing.T) {
		// Verify all platforms implement the same interface
		// We would create instances here, but they require configuration
		// Instead, we verify interface compatibility through type checking

		// Verify interface consistency
		var platformInterface platform.Platform
		interfaceType := reflect.TypeOf(&platformInterface).Elem()

		// Verify interface has expected methods
		expectedMethods := []string{"Name", "Send", "ValidateTarget", "GetCapabilities", "IsHealthy", "Close"}

		for _, methodName := range expectedMethods {
			method, exists := interfaceType.MethodByName(methodName)
			if !exists {
				t.Errorf("Platform interface missing method: %s", methodName)
			} else {
				t.Logf("Platform interface has method: %s with signature: %s", methodName, method.Type)
			}
		}
	})

	t.Run("NoLegacyInterfaceReferences", func(t *testing.T) {
		// Verify no references to old interface names
		legacyInterfaces := []string{
			"InternalSender",
			"ExternalSender",
			"Notifier",
			"PlatformAdapter",
		}

		for _, interfaceName := range legacyInterfaces {
			if checkForInterface(t, interfaceName) {
				t.Errorf("Legacy interface %s still exists in codebase", interfaceName)
			}
		}
	})
}

// BenchmarkCallChainPerformance benchmarks the simplified call chain
func BenchmarkCallChainPerformance(b *testing.B) {
	// Create a hub for benchmarking
	emailConfig := &config.EmailConfig{
		SMTPHost: "smtp.test.com",
		SMTPPort: 587,
		SMTPFrom: "test@test.com",
		Timeout:  1 * time.Millisecond, // Fast timeout for benchmarking
	}

	hub, err := notifyhub.New(notifyhub.WithEmail(emailConfig.SMTPHost, emailConfig.SMTPPort, emailConfig.SMTPFrom))
	if err != nil {
		b.Fatalf("Failed to create hub: %v", err)
	}
	defer hub.Close()

	msg := &message.Message{
		ID:      "bench-msg",
		Title:   "Benchmark Message",
		Body:    "Benchmark Body",
		Format:  "text",
		Targets: []target.Target{
			{Type: "email", Value: "bench@test.com"},
		},
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		ctx := context.Background()
		_, _ = hub.Send(ctx, msg) // Ignore errors for benchmarking
	}
}