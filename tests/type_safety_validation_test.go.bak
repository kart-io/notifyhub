// Package tests provides type safety validation tests for NotifyHub configuration
package tests

import (
	"go/ast"
	"go/parser"
	"go/token"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/kart-io/notifyhub/pkg/notifyhub"
	"github.com/kart-io/notifyhub/pkg/notifyhub/config"
)

// TestStrongTypedConfigurations validates all platform configurations use strong types
func TestStrongTypedConfigurations(t *testing.T) {
	t.Run("EmailConfigStrongTyped", func(t *testing.T) {
		// Test Email configuration strong typing
		emailConfig := &config.EmailConfig{
			SMTPHost:     "smtp.test.com",
			SMTPPort:     587,
			SMTPUsername: "test@test.com",
			SMTPPassword: "password123",
			SMTPFrom:     "noreply@test.com",
			SMTPTLS:      true,
			SMTPSSL:      false,
			Timeout:      30 * time.Second,
			MaxRetries:   3,
			RateLimit:    60,
		}

		// Verify struct has expected fields with correct types
		validateStructType(t, emailConfig, map[string]string{
			"SMTPHost":     "string",
			"SMTPPort":     "int",
			"SMTPUsername": "string",
			"SMTPPassword": "string",
			"SMTPFrom":     "string",
			"SMTPTLS":      "bool",
			"SMTPSSL":      "bool",
			"Timeout":      "time.Duration",
			"MaxRetries":   "int",
			"RateLimit":    "int",
		})

		// Test configuration creation (should compile without type assertions)
		hub, err := notifyhub.New(config.WithEmail(emailConfig))
		if err != nil {
			t.Fatalf("Strong-typed email configuration failed: %v", err)
		}
		defer hub.Close()

		// Verify no runtime type assertions needed
		configType := reflect.TypeOf(emailConfig)
		if configType.Kind() != reflect.Ptr {
			t.Error("Email configuration should be a pointer to struct")
		}
	})

	t.Run("FeishuConfigStrongTyped", func(t *testing.T) {
		// Test Feishu configuration strong typing
		feishuConfig := &config.FeishuConfig{
			WebhookURL:  "https://open.feishu.cn/open-apis/bot/v2/hook/test",
			Secret:      "test-secret",
			AppID:       "test-app-id",
			AppSecret:   "test-app-secret",
			AuthType:    "webhook",
			Timeout:     30 * time.Second,
			MaxRetries:  3,
			RateLimit:   100,
			SignVerify:  true,
		}

		// Verify struct has expected fields with correct types
		validateStructType(t, feishuConfig, map[string]string{
			"WebhookURL":  "string",
			"Secret":      "string",
			"AppID":       "string",
			"AppSecret":   "string",
			"AuthType":    "string",
			"Timeout":     "time.Duration",
			"MaxRetries":  "int",
			"RateLimit":   "int",
			"SignVerify":  "bool",
		})

		// Test configuration creation
		hub, err := notifyhub.New(config.WithFeishu(feishuConfig))
		if err != nil {
			t.Fatalf("Strong-typed Feishu configuration failed: %v", err)
		}
		defer hub.Close()
	})

	t.Run("SMSConfigStrongTyped", func(t *testing.T) {
		// Test SMS configuration strong typing
		smsConfig := &config.SMSConfig{
			Provider:   "twilio",
			APIKey:     "test-api-key",
			APISecret:  "test-api-secret",
			From:       "+1234567890",
			Region:     "us-east-1",
			Timeout:    30 * time.Second,
			MaxRetries: 3,
			RateLimit:  30,
			Templates: map[string]string{
				"welcome": "template-id-1",
				"verify":  "template-id-2",
			},
		}

		// Verify struct has expected fields with correct types
		validateStructType(t, smsConfig, map[string]string{
			"Provider":   "string",
			"APIKey":     "string",
			"APISecret":  "string",
			"From":       "string",
			"Region":     "string",
			"Timeout":    "time.Duration",
			"MaxRetries": "int",
			"RateLimit":  "int",
			"Templates":  "map[string]string",
		})

		// Test configuration creation
		hub, err := notifyhub.New(config.WithSMS(smsConfig))
		if err != nil {
			t.Fatalf("Strong-typed SMS configuration failed: %v", err)
		}
		defer hub.Close()
	})

	t.Run("ConfigValidationAtCompileTime", func(t *testing.T) {
		// Test that invalid configurations are caught at creation time
		invalidEmailConfig := &config.EmailConfig{
			SMTPHost: "", // Invalid: empty required field
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
		}

		// This should fail validation during hub creation
		_, err := notifyhub.New(config.WithEmail(invalidEmailConfig))
		if err == nil {
			t.Error("Expected validation error for invalid email config")
		}

		// Test field type safety (this should not compile if types are wrong)
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com", // string
			SMTPPort: 587,             // int
			SMTPTLS:  true,            // bool
			Timeout:  30 * time.Second, // time.Duration
		}

		// Type-safe assignment without type assertions
		host := emailConfig.SMTPHost     // string
		port := emailConfig.SMTPPort     // int
		useTLS := emailConfig.SMTPTLS    // bool
		timeout := emailConfig.Timeout  // time.Duration

		if host != "smtp.test.com" || port != 587 || !useTLS || timeout != 30*time.Second {
			t.Error("Type-safe field access failed")
		}
	})
}

// TestCompileTimeTypeChecking validates compile-time type checking
func TestCompileTimeTypeChecking(t *testing.T) {
	t.Run("NoRuntimeTypeAssertions", func(t *testing.T) {
		// Analyze source code for type assertions in configuration paths
		typeAssertionCount := countConfigurationTypeAssertions(t)

		// Strong typing should eliminate most type assertions
		maxAllowedAssertions := 5 // Very low threshold
		if typeAssertionCount > maxAllowedAssertions {
			t.Errorf("Too many type assertions in configuration code: %d (max: %d)",
				typeAssertionCount, maxAllowedAssertions)
		}

		t.Logf("Configuration type assertions found: %d", typeAssertionCount)
	})

	t.Run("StructFieldTypes", func(t *testing.T) {
		// Verify all configuration structs have properly typed fields
		configs := []interface{}{
			&config.EmailConfig{},
			&config.FeishuConfig{},
			&config.SMSConfig{},
			&config.SlackConfig{},
			&config.WebhookConfig{},
		}

		for _, cfg := range configs {
			configType := reflect.TypeOf(cfg).Elem()
			configName := configType.Name()

			// Verify no interface{} fields (should use concrete types)
			for i := 0; i < configType.NumField(); i++ {
				field := configType.Field(i)
				fieldType := field.Type

				// Check for interface{} usage (sign of weak typing)
				if fieldType == reflect.TypeOf((*interface{})(nil)).Elem() {
					t.Errorf("%s.%s uses interface{} instead of concrete type", configName, field.Name)
				}

				// Check for map[string]interface{} usage (old pattern)
				if fieldType == reflect.TypeOf(map[string]interface{}{}) {
					t.Errorf("%s.%s uses map[string]interface{} instead of strong typing", configName, field.Name)
				}
			}
		}
	})

	t.Run("ConfigurationValidation", func(t *testing.T) {
		// Test validation tag presence and effectiveness
		emailConfig := &config.EmailConfig{}
		configType := reflect.TypeOf(emailConfig).Elem()

		requiredFields := 0
		validatedFields := 0

		for i := 0; i < configType.NumField(); i++ {
			field := configType.Field(i)
			validateTag := field.Tag.Get("validate")
			jsonTag := field.Tag.Get("json")

			// Count fields with validation tags
			if validateTag != "" {
				validatedFields++
				if strings.Contains(validateTag, "required") {
					requiredFields++
				}
			}

			// Verify JSON tags exist for serialization
			if jsonTag == "" && !strings.HasPrefix(field.Name, "internal") {
				t.Errorf("Field %s.%s missing JSON tag", configType.Name(), field.Name)
			}
		}

		if validatedFields == 0 {
			t.Error("No validation tags found on configuration fields")
		}

		if requiredFields == 0 {
			t.Error("No required field validation found")
		}

		t.Logf("Configuration validation: %d validated fields, %d required fields", validatedFields, requiredFields)
	})
}

// TestFunctionalOptionsPattern validates functional options pattern implementation
func TestFunctionalOptionsPattern(t *testing.T) {
	t.Run("OptionsPatternImplementation", func(t *testing.T) {
		// Verify Option type is a function
		optionType := reflect.TypeOf((*config.Option)(nil)).Elem()
		if optionType.Kind() != reflect.Func {
			t.Error("config.Option should be a function type")
		}

		// Test option composition
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
			Timeout:  30 * time.Second,
		}

		// Multiple options should be composable
		opts := []config.Option{
			config.WithEmail(emailConfig),
			config.WithTimeout(60 * time.Second),
			config.WithMaxRetries(5),
			config.WithMetrics(true),
		}

		hub, err := notifyhub.New(opts...)
		if err != nil {
			t.Fatalf("Options composition failed: %v", err)
		}
		defer hub.Close()

		// Verify options were applied
		hubConfig := hub.GetConfig()
		if hubConfig.DefaultTimeout != 60*time.Second {
			t.Errorf("Timeout option not applied: expected %v, got %v", 60*time.Second, hubConfig.DefaultTimeout)
		}

		if hubConfig.MaxRetries != 5 {
			t.Errorf("MaxRetries option not applied: expected 5, got %d", hubConfig.MaxRetries)
		}

		if !hubConfig.EnableMetrics {
			t.Error("Metrics option not applied")
		}
	})

	t.Run("OptionsTypesSafety", func(t *testing.T) {
		// Test that options maintain type safety
		emailConfig := &config.EmailConfig{
			SMTPHost: "smtp.test.com",
			SMTPPort: 587,
			SMTPFrom: "test@test.com",
		}

		// Option function should be type-safe
		option := config.WithEmail(emailConfig)

		// Option should have correct signature: func(*Config) error
		optionValue := reflect.ValueOf(option)
		optionType := optionValue.Type()

		if optionType.NumIn() != 1 || optionType.NumOut() != 1 {
			t.Error("Option function should have signature func(*Config) error")
		}

		inType := optionType.In(0)
		outType := optionType.Out(0)

		if !strings.Contains(inType.String(), "Config") {
			t.Errorf("Option input should be *Config, got %s", inType.String())
		}

		if outType.Name() != "error" {
			t.Errorf("Option output should be error, got %s", outType.Name())
		}
	})
}

// TestConfigurationUniformity validates consistent configuration patterns
func TestConfigurationUniformity(t *testing.T) {
	t.Run("ConsistentFieldNames", func(t *testing.T) {
		// Verify consistent naming across platform configurations
		platformConfigs := []reflect.Type{
			reflect.TypeOf(config.EmailConfig{}),
			reflect.TypeOf(config.FeishuConfig{}),
			reflect.TypeOf(config.SMSConfig{}),
			reflect.TypeOf(config.SlackConfig{}),
			reflect.TypeOf(config.WebhookConfig{}),
		}

		// Common fields should have consistent names
		commonFields := map[string]string{
			"Timeout":    "time.Duration",
			"MaxRetries": "int",
			"RateLimit":  "int",
		}

		for _, configType := range platformConfigs {
			for fieldName, expectedType := range commonFields {
				field, exists := configType.FieldByName(fieldName)
				if !exists {
					t.Errorf("%s missing common field: %s", configType.Name(), fieldName)
					continue
				}

				if field.Type.String() != expectedType {
					t.Errorf("%s.%s has type %s, expected %s",
						configType.Name(), fieldName, field.Type.String(), expectedType)
				}
			}
		}
	})

	t.Run("ValidationTagConsistency", func(t *testing.T) {
		// Verify consistent validation patterns
		emailType := reflect.TypeOf(config.EmailConfig{})

		// Check that timeout fields have min validation
		timeoutField, exists := emailType.FieldByName("Timeout")
		if exists {
			validateTag := timeoutField.Tag.Get("validate")
			if !strings.Contains(validateTag, "min=") {
				t.Error("Timeout field should have minimum validation")
			}
		}

		// Check that required string fields have required tag
		hostField, exists := emailType.FieldByName("SMTPHost")
		if exists {
			validateTag := hostField.Tag.Get("validate")
			if !strings.Contains(validateTag, "required") {
				t.Error("SMTPHost field should be marked as required")
			}
		}
	})
}

// Helper functions

// validateStructType validates a struct has fields with expected types
func validateStructType(t *testing.T, structPtr interface{}, expectedFields map[string]string) {
	structType := reflect.TypeOf(structPtr).Elem()
	structName := structType.Name()

	for fieldName, expectedType := range expectedFields {
		field, exists := structType.FieldByName(fieldName)
		if !exists {
			t.Errorf("%s missing field: %s", structName, fieldName)
			continue
		}

		actualType := field.Type.String()
		if actualType != expectedType {
			t.Errorf("%s.%s has type %s, expected %s", structName, fieldName, actualType, expectedType)
		}
	}
}

// countConfigurationTypeAssertions counts type assertions in configuration-related code
func countConfigurationTypeAssertions(t *testing.T) int {
	count := 0

	// Packages to analyze for type assertions
	packages := []string{
		"pkg/notifyhub/config",
		"pkg/platforms",
	}

	for _, pkg := range packages {
		count += countTypeAssertionsInConfigPackage(pkg)
	}

	return count
}

// countTypeAssertionsInConfigPackage counts type assertions in a config package
func countTypeAssertionsInConfigPackage(packagePath string) int {
	count := 0

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
	if err != nil {
		return 0
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Look for type assertions: x.(Type)
				if typeAssert, ok := n.(*ast.TypeAssertExpr); ok {
					_ = typeAssert
					count++
				}
				return true
			})
		}
	}

	return count
}