# NotifyHub 功能列表 (基于 v2.0 设计)

本文档根据最终版系统设计，总结了 NotifyHub 计划实现的核心功能。

## 1. 核心 API 与发送模式
- **统一入口 (`Hub`)**: 提供一个中心化的 `Hub` 对象来管理所有操作。
- **流畅的建造者模式**: 通过 `notifyhub.New(With...` API，以链式调用方式灵活配置 `Hub` 实例。
- **双发送模式**:
  - **异步发送 `Send()`**: 将消息推入队列后立即返回，追求高吞吐量。
  - **同步发送 `SendSync()`**: 直接执行发送并阻塞等待结果，用于需要即时反馈的场景。
- **优雅停机 (`Stop()`)**: 提供 `Stop()` 方法以安全关闭 `Hub`，确保所有进行中的任务和连接都能被妥善处理。

## 2. 异步处理与队列系统
- **可插拔队列**: 队列系统被设计为可插拔模块。
- **内置 Worker-Pool 队列**: 自带一个基于 Go channel 的高性能内存队列作为默认选项，无需外部依赖。
- **第三方队列支持 (设计目标)**: 架构上支持通过适配器模式接入专业的持久化消息队列，如 Kafka, Redis Streams。

## 3. 通知渠道 (Notifier)
- **开放的插件化架构**: 定义了标准的 `Notifier` 接口，允许用户在自己的项目中集成任何通知渠道。
- **生命周期管理**: `Notifier` 接口包含 `Shutdown()` 方法，能够安全地管理 gRPC、IM 等长连接资源。
- **支持有状态/无状态**: 提供了清晰的设计模式，用于实现无状态 (如 Webhook) 和有状态 (如 gRPC) 两种类型的通知器。
- **内置渠道**: 已实现 `email` 和 `feishu` 作为基础通知器。

## 4. 路由与消息
- **动态路由**: 内置 `Router` 组件，可根据消息的 `Channel` 字段，自动将其分发到类型匹配的 `Notifier`。
- **结构化消息 (`Message`)**: 使用统一的 `Message` 结构体传递信息，包含路由、内容、模板、重试策略等所有必要数据。

## 5. 可靠性保障
- **精细化重试策略**: 支持全局默认重试策略，并允许在单条 `Message` 上附加独立的 `RetryConfig` 来覆盖默认值，实现对不同消息的差异化处理。
- **详细的错误处理**:
  - **同步模式**: 通过函数直接返回 `error`。
  - **异步模式**: 提供两种回调机制：
    - **单消息完成回调 (`Callback`)**: 对单条消息的最终结果（成功或失败）进行响应。
    - **全局失败处理器 (`FailureHandler`)**: 统一处理所有最终失败的消息，用于全局监控和告警。

## 6. 动态模板系统
- **加载与渲染分离**:
  - **`TemplateProvider`**: 可插拔的模板加载器，支持从文件、内存、远程 API 等多种来源获取模板。
  - **`TemplateEngine`**: 模板渲染引擎，支持向模板中注册自定义函数以处理复杂逻辑。
- **动态指定**: 允许在 `Message` 中通过 `TemplateName` 和 `TemplateData` 动态指定和渲染模板。